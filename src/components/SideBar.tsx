// /opt/blurface/src/components/SideBar.tsx
import React, { useEffect, useRef, useState } from 'react';
import { ContextMenu } from './ContextMenu';
import { ThreadsSection } from './sidebar/ThreadsSection';

type Sender = 'Blur' | 'You' | 'System';
interface Message { sender: Sender; text: string; systemType?: 'announcement' | 'normal'; }
interface Thread { id: string; title: string; autoGenerated: boolean; messages: Message[]; sessionId?: string | null; }
interface ContextMenuState { visible: boolean; x: number; y: number; itemId: string; isThread: boolean; }
interface RenameState { isRenaming: boolean; itemId: string; newName: string; isThread: boolean; }
interface SidebarProps {
  activeSection: string;
  setActiveSection: (section: string) => void;
  activeItem: string | null;
  setActiveItem: (item: string | null) => void;
  threadList: Thread[];
  setThreadList: React.Dispatch<React.SetStateAction<Thread[]>>;
  sidebarCollapsed: boolean;
  onNewConversation: () => void;
}

const PLACEHOLDER = 'new conversation...';
function isPlaceholderTitle(t?: string): boolean {
  const s = (t || '').trim().toLowerCase().replace(/\s+/g, ' ');
  return !s || s === PLACEHOLDER || s === 'first encounter';
}
function heuristicTitle(text: string): string {
  const norm = (text || '').trim().replace(/\s+/g, ' ');
  if (!norm) return 'new chat';
  let base = (norm.match(/^[^.!?]{10,80}[.!?]/)?.[0] ?? norm.split(' ').slice(0, 7).join(' ')).trim();
  base = base.replace(/[.!?]\s*$/, '');
  return base.length > 60 ? base.slice(0, 57) + '…' : base;
}

// --- FIXED: Commented out the function causing the 404 error ---
/*
async function tryAiTitle(firstMsg: string): Promise<string | null> {
  try {
    const port = (await (window as any)?.env?.get?.('BLUR_CORE_PORT')) || '8000';
    const url = `http://127.0.0.1:${port}/title`;
    const r = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: firstMsg }),
    });
    if (!r.ok) return null;
    const data = await r.json();
    const t = (data?.title || '').trim();
    return t || null;
  } catch { return null; }
}
*/

export const Sidebar: React.FC<SidebarProps> = ({
  activeSection,
  setActiveSection,
  activeItem,
  setActiveItem,
  threadList,
  setThreadList,
  sidebarCollapsed,
  onNewConversation,
}) => {
  const [expandedSections, setExpandedSections] = useState<{ threads: boolean }>({ threads: true });
  const [contextMenu, setContextMenu] = useState<ContextMenuState>({ visible: false, x: 0, y: 0, itemId: '', isThread: true });
  const [renameState, setRenameState] = useState<RenameState>({ isRenaming: false, itemId: '', newName: '', isThread: true });
  const renameInputRef = useRef<HTMLInputElement>(null);
  const titledRef = useRef<Set<string>>(new Set());

  useEffect(() => {
    if (renameState.isRenaming) requestAnimationFrame(() => renameInputRef.current?.focus());
  }, [renameState.isRenaming]);

  useEffect(() => {
    const need = threadList.filter((t) => {
      const first = t.messages?.[0]?.text?.trim() || '';
      return isPlaceholderTitle(t.title) && first && !titledRef.current.has(t.id);
    });
    if (need.length === 0) return;

    setThreadList(prev =>
      prev.map(t => {
        if (!need.find(n => n.id === t.id)) return t;
        titledRef.current.add(t.id);
        const guess = heuristicTitle(t.messages?.[0]?.text || '');
        return { ...t, title: guess, autoGenerated: true };
      })
    );

    // --- FIXED: The call to the AI titler has been removed ---
    /*
    (async () => {
      for (const t of need) {
        const first = t.messages?.[0]?.text || '';
        const ai = await tryAiTitle(first);
        if (!ai) continue;
        setThreadList(prev => prev.map(x => x.id === t.id ? { ...x, title: ai, autoGenerated: true } : x));
      }
    })();
    */
  }, [threadList, setThreadList]);

  if (sidebarCollapsed) return null;

  const handleItemClick = (itemId: string) => setActiveItem(itemId);
  const toggleSection = (section: string, e: React.MouseEvent) => {
    e.stopPropagation();
    setExpandedSections(prev => ({ ...prev, [section]: !prev[section as keyof typeof prev] }));
  };
  const handleContextMenu = (e: React.MouseEvent, itemId: string, isThread: boolean) => {
    e.preventDefault();
    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, itemId, isThread });
  };
  const closeContextMenu = () => setContextMenu(prev => ({ ...prev, visible: false }));
  const handleNew = () => onNewConversation();

  const completeRename = () => {
    if (!renameState.isRenaming || !renameState.itemId) return;
    setThreadList(prev =>
      prev.map(t => t.id === renameState.itemId ? { ...t, title: renameState.newName, autoGenerated: false } : t)
    );
    setRenameState({ isRenaming: false, itemId: '', newName: '', isThread: true });
  };
  const handleRenameKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') completeRename();
    else if (e.key === 'Escape') setRenameState({ isRenaming: false, itemId: '', newName: '', isThread: true });
  };

  return (
    <div className="h-full flex flex-col text-white bg-black">
      <div className="py-4 px-4 border-b border-zinc-900 flex items-center h-[57px]">
        <span className="text-2xl font-bold neon-rainbow-glow">∴ blur.</span>
      </div>
      <div className="px-4 py-3">
        <button
          onClick={handleNew}
          className="w-full rounded-md bg-zinc-900 border border-zinc-800 py-2 text-center text-white/90 hover:bg-zinc-800 hover:border-zinc-700 transition-colors"
          aria-label="new conversation"
          title="new"
        >
          ∞ new
        </button>
      </div>
      <div className="flex-1 overflow-y-auto min-h-0">
        <ThreadsSection
          threads={threadList.map(({ id, title }) => ({
            id,
            title: isPlaceholderTitle(title) ? PLACEHOLDER : (title || PLACEHOLDER),
          }))}
          activeItem={activeItem ?? ''}
          expandedSections={expandedSections}
          onToggleSection={(e) => toggleSection('threads', e)}
          onItemClick={handleItemClick}
          onContextMenu={handleContextMenu}
          renameState={renameState}
          renameInputRef={renameInputRef}
          onRenameChange={(e) => setRenameState(prev => ({ ...prev, newName: e.target.value }))}
          onRenameKeyDown={handleRenameKeyDown}
          onRenameBlur={completeRename}
        />
      </div>
      <div className="p-4 border-t border-zinc-900">
        <div className="text-zinc-600 text-sm">⛧ acheintegrated.</div>
      </div>
      {contextMenu.visible && (
        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          onClose={closeContextMenu}
          onDelete={() => {
            if (!contextMenu.isThread) return;
            setThreadList(prev => {
              const next = prev.filter(t => t.id !== contextMenu.itemId);
              if (activeItem === contextMenu.itemId) setActiveItem(next[0]?.id ?? null);
              return next;
            });
            closeContextMenu();
          }}
          onRename={() => {
            const item = threadList.find(t => t.id === contextMenu.itemId);
            if (item) {
              setRenameState({
                isRenaming: true,
                itemId: contextMenu.itemId,
                newName: item.title ?? '',
                isThread: true,
              });
            }
            closeContextMenu();
          }}
        />
      )}
    </div>
  );
};