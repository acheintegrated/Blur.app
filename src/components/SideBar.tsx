import React, { useEffect, useMemo, useRef, useState } from 'react';
import { ContextMenu } from './ContextMenu';
import { ThreadsSection } from './sidebar/ThreadsSection';

/*
  Reforge notes:
  - Titles now derive from the first *meaningful* message (prefer the first `You` message).
  - Filters out System/announcement lines and common mode/tone flip syntaxes.
  - Auto-generated titles update only when the seed text changes; manual renames are respected.
  - Placeholder is preserved if no valid seed exists yet.
*/

type Sender = 'Blur' | 'You' | 'System';
interface Message { sender: Sender; text: string; systemType?: 'announcement' | 'normal'; }
interface Thread { id: string; title: string; autoGenerated: boolean; messages: Message[]; sessionId?: string | null; }
interface ContextMenuState { visible: boolean; x: number; y: number; itemId: string; isThread: boolean; }
interface RenameState { isRenaming: boolean; itemId: string; newName: string; isThread: boolean; }
interface SidebarProps {
  activeSection: string;
  setActiveSection: (section: string) => void;
  activeItem: string | null;
  setActiveItem: (item: string | null) => void;
  threadList: Thread[];
  setThreadList: React.Dispatch<React.SetStateAction<Thread[]>>;
  sidebarCollapsed: boolean;
  onNewConversation: () => void;
}

const PLACEHOLDER = 'new conversation...';

const MODE_CHANGE_PATTERNS: RegExp[] = [
  /^\s*(mode|tone)\s*:\s*/i,
  /^\s*\[(dream|astrofuck)\]\s*$/i,
  /^\s*::\s*(dream|astrofuck)\b/i,
  /^\s*switched\s+to\s+(dream|astrofuck)\b/i,
  /^\s*(—|-)?\s*mode\s+changed\s+to\s+(dream|astrofuck)\s*(—|-)?\s*$/i,
  /^\s*(entering|enter)\s+(dream|astrofuck)\s*mode\b/i,
];

function isPlaceholderTitle(t?: string): boolean {
  const s = (t || '').trim().toLowerCase().replace(/\s+/g, ' ');
  return (
    !s ||
    s === PLACEHOLDER ||
    s === 'first encounter' ||
    s === 'new chat' ||
    s === 'untitled' ||
    s === 'new conversation'
  );
}

function looksLikeModeChange(text?: string): boolean {
  const s = (text || '').trim();
  if (!s) return false;
  return MODE_CHANGE_PATTERNS.some((rx) => rx.test(s));
}

function isSystemish(m?: Message): boolean {
  return !m ? true : m.sender === 'System' || m.systemType === 'announcement';
}

function isTitleCandidate(m?: Message): boolean {
  if (!m) return false;
  const s = (m.text || '').trim();
  if (!s) return false;
  if (isSystemish(m)) return false;
  if (looksLikeModeChange(s)) return false;
  return true;
}

function firstTitleSeed(msgs: Message[]): string {
  if (!Array.isArray(msgs) || msgs.length === 0) return '';
  const userHit = msgs.find((m) => m.sender === 'You' && isTitleCandidate(m));
  if (userHit) return userHit.text.trim();
  const anyHit = msgs.find((m) => isTitleCandidate(m));
  if (anyHit) return anyHit.text.trim();
  return '';
}

function heuristicTitle(text: string): string {
  const norm = (text || '').trim().replace(/\s+/g, ' ');
  if (!norm) return 'new chat';
  // Prefer a sentence-ish span 10-80 chars ending with punctuation; fallback to first 7 words
  let base = (norm.match(/^[^.!?]{10,80}[.!?]/)?.[0] ?? norm.split(' ').slice(0, 7).join(' ')).trim();
  base = base.replace(/[.!?]\s*$/, '');
  return base.length > 60 ? base.slice(0, 57) + '…' : base;
}

function hashSeed(s: string): string {
  // lightweight stable hash (djb2)
  let h = 5381;
  for (let i = 0; i < s.length; i++) h = ((h << 5) + h) ^ s.charCodeAt(i);
  return (h >>> 0).toString(36);
}

export const Sidebar: React.FC<SidebarProps> = ({
  activeSection,
  setActiveSection,
  activeItem,
  setActiveItem,
  threadList,
  setThreadList,
  sidebarCollapsed,
  onNewConversation,
}) => {
  const [expandedSections, setExpandedSections] = useState<{ threads: boolean }>({ threads: true });
  const [contextMenu, setContextMenu] = useState<ContextMenuState>({ visible: false, x: 0, y: 0, itemId: '', isThread: true });
  const [renameState, setRenameState] = useState<RenameState>({ isRenaming: false, itemId: '', newName: '', isThread: true });
  const renameInputRef = useRef<HTMLInputElement>(null);

  // Track which threads we've auto-titled + from which seed (so we can update when that seed changes)
  const seedHashRef = useRef<Map<string, string>>(new Map());

  useEffect(() => {
    if (renameState.isRenaming) requestAnimationFrame(() => renameInputRef.current?.focus());
  }, [renameState.isRenaming]);

  // Compute candidates once per render to avoid double work inside setState
  const titleCandidates = useMemo(() => {
    const out: Array<{ id: string; seed: string; currentTitle: string; autoGenerated: boolean }> = [];
    for (const t of threadList) {
      const seed = firstTitleSeed(t.messages || []);
      out.push({ id: t.id, seed, currentTitle: t.title || '', autoGenerated: !!t.autoGenerated });
    }
    return out;
  }, [threadList]);

  // Auto-title when:
  // 1) Title is placeholder and we have a seed, OR
  // 2) Title was autoGenerated before and the seed changed.
  useEffect(() => {
    const updates: Record<string, { title: string; autoGenerated: boolean }> = {};

    for (const { id, seed, currentTitle, autoGenerated } of titleCandidates) {
      const hasSeed = !!seed.trim();
      const isPlaceholder = isPlaceholderTitle(currentTitle);
      const prevHash = seedHashRef.current.get(id);
      const nextHash = hasSeed ? hashSeed(seed) : '';

      const shouldTitleBecausePlaceholder = isPlaceholder && hasSeed;
      const shouldRefreshAuto = autoGenerated && hasSeed && prevHash && prevHash !== nextHash;

      if (shouldTitleBecausePlaceholder || shouldRefreshAuto) {
        updates[id] = { title: heuristicTitle(seed), autoGenerated: true };
        if (hasSeed) seedHashRef.current.set(id, nextHash);
      } else if (hasSeed && (!prevHash || prevHash !== nextHash) && (isPlaceholder || autoGenerated)) {
        // keep hash in sync even if we decided not to change title this tick
        seedHashRef.current.set(id, nextHash);
      }
    }

    const ids = Object.keys(updates);
    if (ids.length === 0) return;

    setThreadList((prev) =>
      prev.map((t) => (updates[t.id] ? { ...t, ...updates[t.id] } : t))
    );
  }, [titleCandidates, setThreadList]);

  if (sidebarCollapsed) return null;

  const handleItemClick = (itemId: string) => setActiveItem(itemId);

  const toggleSection = (section: string, e: React.MouseEvent) => {
    e.stopPropagation();
    setExpandedSections((prev) => ({ ...prev, [section]: !prev[section as keyof typeof prev] }));
  };

  const handleContextMenu = (e: React.MouseEvent, itemId: string, isThread: boolean) => {
    e.preventDefault();
    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, itemId, isThread });
  };

  const closeContextMenu = () => setContextMenu((prev) => ({ ...prev, visible: false }));

  const handleNew = () => onNewConversation();

  const completeRename = () => {
    if (!renameState.isRenaming || !renameState.itemId) return;
    const next = renameState.newName.trim();
    setThreadList((prev) =>
      prev.map((t) =>
        t.id === renameState.itemId
          ? {
              ...t,
              title: next || t.title, // don't nuke to empty
              autoGenerated: false, // manual rename locks it
            }
          : t
      )
    );
    // lock out future auto-retitling by clearing stored seed hash (optional but explicit)
    seedHashRef.current.delete(renameState.itemId);

    setRenameState({ isRenaming: false, itemId: '', newName: '', isThread: true });
  };

  const handleRenameKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') completeRename();
    else if (e.key === 'Escape') setRenameState({ isRenaming: false, itemId: '', newName: '', isThread: true });
  };

  return (
    <div className="h-full flex flex-col text-white bg-black">
      <div className="py-4 px-4 border-b border-zinc-900 flex items-center h-[57px]">
        <span className="text-2xl font-bold neon-rainbow-glow">∴ blur.</span>
      </div>

      <div className="px-4 py-3">
        <button
          onClick={handleNew}
          className="w-full rounded-md bg-zinc-900 border border-zinc-800 py-2 text-center text-white/90 hover:bg-zinc-800 hover:border-zinc-700 transition-colors"
          aria-label="new conversation"
          title="new"
        >
          new ⇌ chat
        </button>
      </div>

      <div className="flex-1 overflow-y-auto min-h-0">
        <ThreadsSection
          threads={threadList.map(({ id, title }) => ({
            id,
            title: isPlaceholderTitle(title) ? PLACEHOLDER : title || PLACEHOLDER,
          }))}
          activeItem={activeItem ?? ''}
          expandedSections={expandedSections}
          onToggleSection={(e) => toggleSection('threads', e)}
          onItemClick={handleItemClick}
          onContextMenu={handleContextMenu}
          renameState={renameState}
          renameInputRef={renameInputRef}
          onRenameChange={(e) => setRenameState((prev) => ({ ...prev, newName: e.target.value }))}
          onRenameKeyDown={handleRenameKeyDown}
          onRenameBlur={completeRename}
        />
      </div>

      <div className="p-4 border-t border-zinc-900">
        <div className="text-zinc-600 text-sm">⛧ acheintegrated.</div>
      </div>

      {contextMenu.visible && (
        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          onClose={closeContextMenu}
          onDelete={() => {
            if (!contextMenu.isThread) return;
            setThreadList((prev) => {
              const next = prev.filter((t) => t.id !== contextMenu.itemId);
              if (activeItem === contextMenu.itemId) setActiveItem(next[0]?.id ?? null);
              // Keep seed cache clean
              seedHashRef.current.delete(contextMenu.itemId);
              return next;
            });
            closeContextMenu();
          }}
          onRename={() => {
            const item = threadList.find((t) => t.id === contextMenu.itemId);
            if (item) {
              setRenameState({
                isRenaming: true,
                itemId: contextMenu.itemId,
                newName: item.title ?? '',
                isThread: true,
              });
            }
            closeContextMenu();
          }}
        />
      )}
    </div>
  );
};
