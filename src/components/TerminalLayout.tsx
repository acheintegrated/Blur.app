// /opt/blurface/src/components/TerminalLayout.tsx
// REFORGED v3.4 — Wire up ContextMenu (right-click), safe delete, rename request event, preserve existing props

import React, { useState, useCallback, useRef, useEffect } from 'react';
import { Sidebar } from './SideBar';
import { MainContent } from './MainContent';
import { CommandInput } from './CommandInput';
import { Settings } from './Settings';
import { XIcon } from 'lucide-react';
import { ContextMenu } from './ContextMenu'; // ← USE the menu

interface Message {
  sender: 'Blur' | 'You' | 'System';
  text: string;
  systemType?: 'announcement' | 'normal';
}

interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}

// --- Context menu + rename props (as given) ---
interface ContextMenuState {
  visible: boolean;
  x: number;
  y: number;
  itemId: string;
  itemType: 'thread';
}

interface RenameState {
  isRenaming: boolean;
  itemId: string;
  newName: string;
}

interface TerminalLayoutProps {
  activeItem: string | null;
  setActiveItem: (item: string | null) => void;
  sidebarCollapsed: boolean;
  setSidebarCollapsed: (collapsed: boolean) => void;
  threadList: Thread[];
  setThreadList: (threads: Thread[]) => void;
  onNewCommand: (command: string) => void;
  onNewConversation: () => void;
  currentMode: 'dream' | 'astrofuck';
  onModeToggle: () => void;
  connectionStatus: 'initializing' | 'connecting' | 'loading_model' | 'ready' | 'error';
  onStopGeneration: () => void;
  isLoading: boolean;
  onThreadContextMenu?: (e: React.MouseEvent, id: string) => void;
  renameState: RenameState;
  renameInputRef: React.RefObject<HTMLInputElement>;
  onRenameChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onRenameKeyDown: (e: React.KeyboardEvent) => void;
  onRenameBlur: () => void;
}

export const TerminalLayout: React.FC<TerminalLayoutProps> = (props) => {
  const {
    activeItem,
    setActiveItem,
    sidebarCollapsed,
    setSidebarCollapsed,
    threadList,
    setThreadList,
    onNewCommand,
    onNewConversation,
    currentMode,
    onModeToggle,
    connectionStatus,
    onStopGeneration,
    isLoading,
    // external hooks (kept)
    onThreadContextMenu: onThreadContextMenuExternal,
    renameState,
    renameInputRef,
    onRenameChange,
    onRenameKeyDown,
    onRenameBlur,
  } = props;

  const [showSettings, setShowSettings] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280);
  const [isDragging, setIsDragging] = useState(false);
  const isResizing = useRef(false);
  const [streamingToken, setStreamingToken] = useState(0);

  // --- NEW: local context-menu state
  const [ctxMenu, setCtxMenu] = useState<ContextMenuState | null>(null);

  const activeThread = threadList.find((t) => t.id === activeItem);
  const currentMessages = activeThread?.messages || [];

  const handleNewCommandLocal = (command: string) => {
    if (!activeItem || isLoading) return;
    onNewCommand(command);
  };

  const toggleSidebar = () => setSidebarCollapsed(!sidebarCollapsed);
  const openSettings = () => setShowSettings(true);
  const closeSettings = () => setShowSettings(false);
  const handleModeChange = () => onModeToggle();

  // --- RESIZER
  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    const minWidth = 220;
    const maxWidth = Math.round(window.innerWidth / 3);
    const newWidth = e.clientX;
    if (newWidth >= minWidth && newWidth <= maxWidth) setSidebarWidth(newWidth);
  }, []);

  const handleMouseUp = useCallback(() => {
    isResizing.current = false;
    setIsDragging(false);
    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);
    document.body.style.userSelect = 'auto';
  }, [handleMouseMove]);

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      isResizing.current = true;
      setIsDragging(true);
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      document.body.style.userSelect = 'none';
    },
    [handleMouseMove, handleMouseUp]
  );

  useEffect(() => {
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);

  // stream tick → keep MainContent refreshed
  useEffect(() => {
    const onChunk = () => setStreamingToken((t) => t + 1);
    window.addEventListener('blur:stream-chunk', onChunk as EventListener);
    return () => window.removeEventListener('blur:stream-chunk', onChunk as EventListener);
  }, []);

  // --- NEW: context menu open handler (used + forwarded)
  const handleThreadContextMenu = useCallback(
    (e: React.MouseEvent, id: string) => {
      e.preventDefault();
      // bring thread into focus
      if (id !== activeItem) setActiveItem(id);

      // clamp position to viewport (basic)
      const pad = 8;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const x = Math.min(Math.max(e.clientX, pad), vw - 180); // ~menu width
      const y = Math.min(Math.max(e.clientY, pad), vh - 100); // ~menu height

      setCtxMenu({
        visible: true,
        x,
        y,
        itemId: id,
        itemType: 'thread',
      });

      // still allow external hook if provided
      if (onThreadContextMenuExternal) {
        try { onThreadContextMenuExternal(e, id); } catch {}
      }
    },
    [activeItem, onThreadContextMenuExternal, setActiveItem]
  );

  // Close menu on scroll/resize automatically
  useEffect(() => {
    if (!ctxMenu?.visible) return;
    const close = () => setCtxMenu(null);
    window.addEventListener('scroll', close, true);
    window.addEventListener('resize', close);
    return () => {
      window.removeEventListener('scroll', close, true);
      window.removeEventListener('resize', close);
    };
  }, [ctxMenu?.visible]);

  // --- NEW: menu actions
  const closeMenu = () => setCtxMenu(null);

  const deleteThread = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    const idx = threadList.findIndex((t) => t.id === id);
    if (idx === -1) return;

    const updated = threadList.filter((t) => t.id !== id);
    setThreadList(updated);

    // choose a new active item
    if (activeItem === id) {
      const fallback = updated[idx] || updated[idx - 1] || updated[0] || null;
      setActiveItem(fallback ? fallback.id : null);
    }
    closeMenu();
  };

  const requestRename = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;

    // Make target active so inline input (if any) is visible
    if (activeItem !== id) setActiveItem(id);

    // Fire a rename request event so Sidebar/parent can flip renameState
    window.dispatchEvent(new CustomEvent('blur:rename-request', { detail: { id } }));

    // Try to focus existing input if parent already wired renameInputRef
    setTimeout(() => {
      try { renameInputRef?.current?.focus?.(); } catch {}
    }, 0);

    closeMenu();
  };

  return (
    <div className="flex flex-col h-full bg-black relative">
      <div className="flex flex-1 overflow-hidden">
        <div
          className={`relative flex-shrink-0 border-r border-zinc-900 ${
            sidebarCollapsed ? 'w-0 !border-none' : ''
          } ${!isDragging ? 'transition-all duration-300' : ''}`}
          style={!sidebarCollapsed ? { width: `${sidebarWidth}px` } : {}}
        >
          <div className="h-full w-full overflow-hidden">
            <Sidebar
              activeSection="threads"
              setActiveSection={() => {}}
              activeItem={activeItem}
              setActiveItem={setActiveItem}
              threadList={threadList}
              setThreadList={setThreadList}
              sidebarCollapsed={sidebarCollapsed}
              onNewConversation={onNewConversation}
              // NOW actually used: right-click opens ContextMenu
              onThreadContextMenu={handleThreadContextMenu}
              renameState={renameState}
              renameInputRef={renameInputRef}
              onRenameChange={onRenameChange}
              onRenameKeyDown={onRenameKeyDown}
              onRenameBlur={onRenameBlur}
            />
          </div>

          {!sidebarCollapsed && (
            <div
              onMouseDown={handleMouseDown}
              className={`absolute top-0 right-[-4px] h-full w-2 z-20 cursor-col-resize transition-colors duration-200 ${
                isDragging ? 'resizer-ache-glow' : 'hover:resizer-ache-glow'
              }`}
              title="Resize sidebar"
            />
          )}
        </div>

        <div className="flex-1 flex flex-col overflow-hidden">
          <div className="h-[57px] border-b border-zinc-900 flex items-center justify-between px-4 flex-shrink-0">
            <div className="flex items-center space-x-2">
              <div className="flex items-center justify-center cursor-pointer" onClick={toggleSidebar}>
                <span className="text-3xl text-gray-400 hover:text-white transition-colors duration-150 icon-font mt-[7px]">
                  ☾
                </span>
              </div>
              {sidebarCollapsed && (
                <span className="ml-2">
                  <span className="text-white text-2xl font-bold acheintegrated-glow">∴ blur.</span>
                </span>
              )}
            </div>

            <div className="flex items-center">
              <div
                className={`flex items-center justify-center cursor-pointer mode-button blur-glow-hover ${
                  currentMode === 'astrofuck' ? 'mode-astrofuck-active' : ''
                }`}
                onClick={handleModeChange}
              >
                <span className="text-3xl icon-font">∅</span>
              </div>
              <div className="mode-separator">
                <span className="text-2xl icon-font">|</span>
              </div>
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${
                  currentMode === 'dream' ? 'mode-dream-active' : 'blur-glow-hover'
                }`}
                onClick={handleModeChange}
              >
                <span className="text-3xl icon-font">∞</span>
              </div>
            </div>

            <div className="flex items-center">
              <div className="flex items-center justify-center cursor-pointer" onClick={openSettings}>
                <span className="text-3xl hover:text-white text-gray-400 transition-colors duration-150 icon-font -mt-[3px]">
                  🜃
                </span>
              </div>
            </div>
          </div>

          <div className="flex-1 min-h-0 overflow-hidden">
            <MainContent messages={currentMessages} streamingToken={streamingToken} />
          </div>

          <div className="mt-auto flex-shrink-0">
            <CommandInput
              onSendMessage={handleNewCommandLocal}
              isLoading={isLoading}
              connectionStatus={connectionStatus}
            />
          </div>
        </div>
      </div>

      {showSettings && <Settings onClose={closeSettings} />}

      {/* NEW: Render the context menu */}
      {ctxMenu?.visible && (
        <ContextMenu
          x={ctxMenu.x}
          y={ctxMenu.y}
          onClose={closeMenu}
          onDelete={deleteThread}
          onRename={requestRename}
        />
      )}
    </div>
  );
};
