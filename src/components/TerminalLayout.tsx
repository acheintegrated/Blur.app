// /opt/blurface/src/components/TerminalLayout.tsx
// REFORGED v4.3 — Full-width Neon Beam (moon ⇄ earth), no tooltip, no fork

import React, { useState, useCallback, useRef, useEffect } from 'react';
import { Sidebar } from './SideBar';
import { MainContent } from './MainContent';
import { CommandInput } from './CommandInput';
import { Settings } from './Settings';
import { ContextMenu } from './ContextMenu';
import { CursorGlow } from './CursorGlow';

interface Message {
  sender: 'Blur' | 'You' | 'System';
  text: string;
  systemType?: 'announcement' | 'normal';
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}

interface ContextMenuState {
  visible: boolean;
  x: number;
  y: number;
  itemId: string;
  itemType: 'thread';
}
interface RenameState {
  isRenaming: boolean;
  itemId: string;
  newName: string;
}
type Mode = 'dream' | 'astrofuck';
type ConnectionStatus = 'initializing' | 'connecting' | 'loading_model' | 'ready' | 'error';

interface TerminalLayoutProps {
  activeItem: string | null;
  setActiveItem: (item: string | null) => void;
  sidebarCollapsed: boolean;
  setSidebarCollapsed: (collapsed: boolean) => void;
  threadList: Thread[];
  setThreadList: (threads: Thread[]) => void;

  onNewCommand: (command: string, threadIdHint?: string) => void;
  onNewConversation: () => void;
  currentMode: Mode;
  onModeToggle: () => void;

  connectionStatus: ConnectionStatus;
  onStopGeneration: () => void;
  isLoading: boolean;

  onThreadContextMenu?: (e: React.MouseEvent, id: string) => void;
  renameState: RenameState;
  renameInputRef: React.RefObject<HTMLInputElement>;
  onRenameChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onRenameKeyDown: (e: React.KeyboardEvent) => void;
  onRenameBlur: () => void;
}

export const TerminalLayout: React.FC<TerminalLayoutProps> = (props) => {
  const {
    activeItem,
    setActiveItem,
    sidebarCollapsed,
    setSidebarCollapsed,
    threadList,
    setThreadList,
    onNewCommand,
    onNewConversation,
    currentMode,
    onModeToggle,
    connectionStatus,
    onStopGeneration,
    isLoading,
    onThreadContextMenu: onThreadContextMenuExternal,
    renameState,
    renameInputRef,
    onRenameChange,
    onRenameKeyDown,
    onRenameBlur,
  } = props;

  const [showSettings, setShowSettings] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280);
  const [isDragging, setIsDragging] = useState(false);
  const isResizing = useRef(false);
  const [streamingToken, setStreamingToken] = useState(0);

  const [ctxMenu, setCtxMenu] = useState<ContextMenuState | null>(null);

  // mode switching
  const [isSwitchingMode, setIsSwitchingMode] = useState(false);
  const queuedSwitch = useRef(false);
  const switchStartAt = useRef<number>(0);
  const lastIntentId = useRef<number>(0);
  const MIN_INDICATOR_MS = 420;
  const COOLDOWN_MS = 800;
  const HARD_TIMEOUT_MS = 20_000;

  const activeThread = threadList.find((t) => t.id === activeItem);
  const currentMessages = activeThread?.messages || [];

  // CUT marker on last assistant msg — always end with exactly one █ (no ▍)
  const markLastAssistantCut = useCallback(() => {
    if (!activeItem) return;
    const BLOCK = '█';
    const STREAM_TAIL = /[▍█\s]+$/u;

    setThreadList(prev => {
      const idx = prev.findIndex(t => t.id === activeItem);
      if (idx === -1) return prev;
      const t = prev[idx];
      if (!t.messages.length) return prev;

      const last = t.messages[t.messages.length - 1];
      if (last.sender !== 'Blur') return prev;

      const lastText = (last.text ?? '');
      const cleaned = lastText.replace(STREAM_TAIL, '');
      const updated = [...t.messages];
      updated[updated.length - 1] = { ...last, text: cleaned + BLOCK };

      const next = [...prev];
      next[idx] = { ...t, messages: updated };
      return next;
    });
  }, [activeItem, setThreadList]);

  /* SEND (never gate on activeItem) */
  const handleNewCommandLocal = (command: string) => {
    if (isSwitchingMode) return;
    onNewCommand(command, activeItem || undefined);
  };

  /* STOP (wired into CommandInput) */
  const handleStopLocal = React.useCallback(() => {
    try { markLastAssistantCut(); } catch {}
    try { onStopGeneration(); } catch {}
    try { window.dispatchEvent(new CustomEvent('blur:stop')); } catch {}
  }, [onStopGeneration, markLastAssistantCut]);

  /* UI helpers */
  const toggleSidebar = () => setSidebarCollapsed(!sidebarCollapsed);
  const openSettings = () => setShowSettings(true);
  const closeSettings = () => setShowSettings(false);

  /* Mode switch visuals */
  const endSwitchVisual = useCallback(() => {
    const elapsed = Date.now() - switchStartAt.current;
    const remain = Math.max(0, MIN_INDICATOR_MS - elapsed);
    window.setTimeout(() => setIsSwitchingMode(false), remain);
  }, []);

  useEffect(() => {
    if (isSwitchingMode && connectionStatus === 'ready') endSwitchVisual();
  }, [connectionStatus, isSwitchingMode, endSwitchVisual]);

  useEffect(() => {
    if (!isSwitchingMode) return;
    const onComplete = () => endSwitchVisual();
    const onError = () => endSwitchVisual();
    window.addEventListener('blur:mode-ready', onComplete as EventListener);
    window.addEventListener('blur:mode-switch-complete', onComplete as EventListener);
    window.addEventListener('blur:mode-switch-error', onError as EventListener);
    const hard = window.setTimeout(onError, HARD_TIMEOUT_MS);
    return () => {
      window.removeEventListener('blur:mode-ready', onComplete as EventListener);
      window.removeEventListener('blur:mode-switch-complete', onComplete as EventListener);
      window.removeEventListener('blur:mode-switch-error', onError as EventListener);
      window.clearTimeout(hard);
    };
  }, [isSwitchingMode, endSwitchVisual]);

  const requestModeSwitch = useCallback(() => {
    const now = Date.now();
    if (isSwitchingMode) { queuedSwitch.current = true; return; }
    if (now - (switchStartAt.current || 0) < COOLDOWN_MS) return;

    lastIntentId.current += 1;
    const intentId = lastIntentId.current;
    switchStartAt.current = now;
    setIsSwitchingMode(true);

    try { window.dispatchEvent(new CustomEvent('blur:mode-switch-start', { detail: { intentId, from: currentMode } })); } catch {}
    try { if (isLoading) markLastAssistantCut(); onStopGeneration(); } catch {}
    try { onModeToggle(); } catch {}
  }, [currentMode, isSwitchingMode, onModeToggle, onStopGeneration, isLoading, markLastAssistantCut]);

  useEffect(() => {
    if (!isSwitchingMode && queuedSwitch.current) {
      queuedSwitch.current = false;
      const t = window.setTimeout(() => requestModeSwitch(), 50);
      return () => window.clearTimeout(t);
    }
  }, [isSwitchingMode, requestModeSwitch]);

  /* Resizer */
  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    const minWidth = 220;
    const maxWidth = Math.round(window.innerWidth / 3);
    const newWidth = e.clientX;
    if (newWidth >= minWidth && newWidth <= maxWidth) setSidebarWidth(newWidth);
  }, []);

  const handleMouseUp = useCallback(() => {
    isResizing.current = false;
    setIsDragging(false);
    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);
    document.body.style.userSelect = 'auto';
  }, [handleMouseMove]);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    isResizing.current = true;
    setIsDragging(true);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    document.body.style.userSelect = 'none';
  }, [handleMouseMove, handleMouseUp]);

  useEffect(() => {
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);

  /* Stream tick for MainContent */
  useEffect(() => {
    const onChunk = () => setStreamingToken((t) => t + 1);
    window.addEventListener('blur:stream-chunk', onChunk as EventListener);
    return () => window.removeEventListener('blur:stream-chunk', onChunk as EventListener);
  }, []);

  /* Context menu */
  const handleThreadContextMenu = useCallback((e: React.MouseEvent, id: string) => {
    e.preventDefault();
    if (id !== activeItem) setActiveItem(id);

    const pad = 8;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const x = Math.min(Math.max(e.clientX, pad), vw - 180);
    const y = Math.min(Math.max(e.clientY, pad), vh - 100);

    setCtxMenu({ visible: true, x, y, itemId: id, itemType: 'thread' });

    if (onThreadContextMenuExternal) {
      try { onThreadContextMenuExternal(e, id); } catch {}
    }
  }, [activeItem, onThreadContextMenuExternal, setActiveItem]);

  useEffect(() => {
    if (!ctxMenu?.visible) return;
    const close = () => setCtxMenu(null);
    window.addEventListener('scroll', close, true);
    window.addEventListener('resize', close);
    return () => {
      window.removeEventListener('scroll', close, true);
      window.removeEventListener('resize', close);
    };
  }, [ctxMenu?.visible]);

  const closeMenu = () => setCtxMenu(null);

  const deleteThread = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    const idx = threadList.findIndex((t) => t.id === id);
    if (idx === -1) return;

    const updated = threadList.filter((t) => t.id !== id);
    setThreadList(updated);

    if (activeItem === id) {
      const fallback = updated[idx] || updated[idx - 1] || updated[0] || null;
      setActiveItem(fallback ? fallback.id : null);
    }
    closeMenu();
  };

  const requestRename = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    if (activeItem !== id) setActiveItem(id);
    window.dispatchEvent(new CustomEvent('blur:rename-request', { detail: { id } }));
    setTimeout(() => { try { renameInputRef?.current?.focus?.(); } catch {} }, 0);
    closeMenu();
  };

  /* ===== Neon beam (full header width, center-out, no fork) ===== */
  const ModeHeaderBeam: React.FC<{ active: boolean }> = ({ active }) => (
    <div className="pointer-events-none absolute inset-x-0 bottom-[-1px] h-[2px] z-10">
      <style>{`
        @keyframes beamUnfold {
          0%   { clip-path: inset(0 50% 0 50%); opacity: 0; }
          8%   { opacity: 1; }
          100% { clip-path: inset(0 0 0 0); opacity: 1; }
        }
        @keyframes beamFade {
          0%   { opacity: 1; }
          70%  { opacity: 1; }
          100% { opacity: 0; }
        }

        .beam-line {
          position: absolute;
          inset: 0;
          border-radius: 1px;
          background: #ffffff; /* white-hot core */
          box-shadow:
            0 0 6px  rgba(255,255,200,.95),
            0 0 14px rgba(255,235,59,.95),
            0 0 28px rgba(255,235,59,.75),
            0 0 52px rgba(255,235,59,.5);
          filter: saturate(220%) brightness(120%);
          will-change: clip-path, opacity;
        }

        .beam-anim {
          animation:
            beamUnfold 120ms cubic-bezier(.3,.8,.2,1) forwards,
            beamFade   240ms ease-out forwards;
        }

        /* Fallback if clip-path unsupported (rare in Electron) */
        @supports not (clip-path: inset(0 50% 0 50%)) {
          .beam-line { transform-origin: center; transform: scaleX(0.001); }
          @keyframes beamScale { to { transform: scaleX(1); opacity: 1; } }
          .beam-anim { animation: beamScale 120ms cubic-bezier(.3,.8,.2,1) forwards, beamFade 240ms ease-out forwards; }
        }
      `}</style>
      {active && <div className="beam-line beam-anim" />}
    </div>
  );

  const handleNewConversationLocal = useCallback(() => {
    try { if (isLoading) markLastAssistantCut(); onStopGeneration(); } catch {}
    onNewConversation();
  }, [isLoading, onStopGeneration, onNewConversation, markLastAssistantCut]);

  /* Render */
  return (
    <div className="flex flex-col h-full bg-black relative">
      {/* CursorGlow — stronger while streaming */}
      <CursorGlow isEmphatic={isLoading} />

      {/* Inject pulse keyframes/class in case globals didn’t compile them */}
      <style id="stop-pulse-inject">{`
        @keyframes pulse-scale-slow-fixed { 0%,100% { transform: scale(1);} 50% { transform: scale(1.12);} }
        .anim-stop-glow-pulse {
          display:inline-block !important;
          will-change: text-shadow, transform;
          animation: neon-dynamic-glow 6s linear infinite, pulse-scale-slow-fixed 2.8s ease-in-out infinite !important;
          text-shadow: 0 0 5px rgba(242,0,242,.9), 0 0 10px rgba(242,0,242,.8), 0 0 20px rgba(242,0,242,.7);
        }
      `}</style>

      <div className="flex flex-1 overflow-hidden">
        <div
          className={`relative flex-shrink-0 border-r border-zinc-900 ${sidebarCollapsed ? 'w-0 !border-none' : ''} ${!isDragging ? 'transition-all duration-300' : ''}`}
          style={!sidebarCollapsed ? { width: `${sidebarWidth}px` } : {}}
        >
          <div className="h-full w-full overflow-hidden">
            <Sidebar
              activeSection="threads"
              setActiveSection={() => {}}
              activeItem={activeItem}
              setActiveItem={setActiveItem}
              threadList={threadList}
              setThreadList={setThreadList}
              sidebarCollapsed={sidebarCollapsed}
              onNewConversation={handleNewConversationLocal}
              onThreadContextMenu={handleThreadContextMenu}
              renameState={renameState}
              renameInputRef={renameInputRef}
              onRenameChange={onRenameChange}
              onRenameKeyDown={onRenameKeyDown}
              onRenameBlur={onRenameBlur}
            />
          </div>

          {!sidebarCollapsed && (
            <div
              onMouseDown={handleMouseDown}
              className={`absolute top-0 right-[-4px] h-full w-2 z-20 cursor-col-resize transition-colors duration-200 ${isDragging ? 'resizer-ache-glow' : 'hover:resizer-ache-glow'}`}
              title="Resize sidebar"
            />
          )}
        </div>

        <div className="flex-1 flex flex-col overflow-hidden">
          {/* Header is relative so beam can fill full width */}
          <div className="relative h-[57px] border-b border-zinc-900 flex items-center justify-between px-4 flex-shrink-0">
            <div className="flex items-center space-x-2">
              <div className="flex items-center justify-center cursor-pointer" onClick={toggleSidebar}>
                <span className="text-3xl text-gray-400 hover:text-white transition-colors duration-150 icon-font mt-[7px]">☾</span>
              </div>
              {sidebarCollapsed && (
                <span className="ml-2">
                  <span className="text-white text-2xl font-bold acheintegrated-glow">∴ blur.</span>
                </span>
              )}
            </div>

            <div className="flex items-center">
              {/* ø — no title (no tooltip) */}
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${isSwitchingMode ? 'opacity-50 pointer-events-none' : 'blur-glow-hover'} ${currentMode === 'astrofuck' ? 'mode-astrofuck-active' : ''}`}
                onClick={requestModeSwitch}
              >
                <span className="text-3xl icon-font">∅</span>
              </div>
              <div className="mode-separator">
                <span className="text-2xl icon-font">|</span>
              </div>
              {/* ∞ — no title (no tooltip) */}
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${isSwitchingMode ? 'opacity-50 pointer-events-none' : (currentMode === 'dream' ? 'mode-dream-active' : 'blur-glow-hover')}`}
                onClick={requestModeSwitch}
              >
                <span className="text-3xl icon-font">∞</span>
              </div>
            </div>

            <div className="flex items-center">
              <div className="flex items-center justify-center cursor-pointer" onClick={openSettings}>
                <span className="text-3xl hover:text-white text-gray-400 transition-colors duration-150 icon-font -mt-[3px]">🜃</span>
              </div>
            </div>

            {/* full-width lightning beam under the zinc border */}
            <ModeHeaderBeam active={isSwitchingMode} />
          </div>

          <div className="flex-1 min-h-0 overflow-hidden">
            <MainContent messages={currentMessages} streamingToken={streamingToken} />
          </div>

          <div className="mt-auto flex-shrink-0">
            <CommandInput
              onSendMessage={handleNewCommandLocal}
              onStop={handleStopLocal}
              connectionStatus={connectionStatus}
              isLoading={isLoading || isSwitchingMode}
              threadId={activeItem || ''}
            />
          </div>
        </div>
      </div>

      {showSettings && <Settings onClose={closeSettings} />}

      {ctxMenu?.visible && (
        <ContextMenu
          x={ctxMenu.x}
          y={ctxMenu.y}
          onClose={closeMenu}
          onDelete={deleteThread}
          onRename={requestRename}
        />
      )}
    </div>
  );
};
