// /opt/blurface/src/components/TerminalLayout.tsx
// REFORGED v3.9 — Voidless Send + Coalesced Mode Switch + Context Menu
// - SEND: Never block on missing activeItem. Forward thread hint; App will create/focus.
// - UI: keeps shimmer/spinner, CUT marker, context menu, safe delete/rename.
// - API: onNewCommand(message, threadId?) optional param supported.

import React, { useState, useCallback, useRef, useEffect } from 'react';
import { Sidebar } from './SideBar';
import { MainContent } from './MainContent';
import { CommandInput } from './CommandInput';
import { Settings } from './Settings';
import { XIcon } from 'lucide-react';
import { ContextMenu } from './ContextMenu';

interface Message {
  sender: 'Blur' | 'You' | 'System';
  text: string;
  systemType?: 'announcement' | 'normal';
}

interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}

/* ---------------- Types ---------------- */
interface ContextMenuState {
  visible: boolean;
  x: number;
  y: number;
  itemId: string;
  itemType: 'thread';
}

interface RenameState {
  isRenaming: boolean;
  itemId: string;
  newName: string;
}

type Mode = 'dream' | 'astrofuck';
type ConnectionStatus = 'initializing' | 'connecting' | 'loading_model' | 'ready' | 'error';

interface TerminalLayoutProps {
  activeItem: string | null;
  setActiveItem: (item: string | null) => void;
  sidebarCollapsed: boolean;
  setSidebarCollapsed: (collapsed: boolean) => void;
  threadList: Thread[];
  // Note: parent keeps the React.SetStateAction; here we accept simple setter for compatibility
  setThreadList: (threads: Thread[]) => void;

  // ⬇️ accepts optional thread hint — App will create/focus if needed
  onNewCommand: (command: string, threadIdHint?: string) => void;

  onNewConversation: () => void;
  currentMode: Mode;
  onModeToggle: () => void;
  connectionStatus: ConnectionStatus;
  onStopGeneration: () => void;
  isLoading: boolean;

  // rename/context hooks (unchanged)
  onThreadContextMenu?: (e: React.MouseEvent, id: string) => void;
  renameState: RenameState;
  renameInputRef: React.RefObject<HTMLInputElement>;
  onRenameChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onRenameKeyDown: (e: React.KeyboardEvent) => void;
  onRenameBlur: () => void;
}

export const TerminalLayout: React.FC<TerminalLayoutProps> = (props) => {
  const {
    activeItem,
    setActiveItem,
    sidebarCollapsed,
    setSidebarCollapsed,
    threadList,
    setThreadList,
    onNewCommand,
    onNewConversation,
    currentMode,
    onModeToggle,
    connectionStatus,
    onStopGeneration,
    isLoading,
    onThreadContextMenu: onThreadContextMenuExternal,
    renameState,
    renameInputRef,
    onRenameChange,
    onRenameKeyDown,
    onRenameBlur,
  } = props;

  const [showSettings, setShowSettings] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280);
  const [isDragging, setIsDragging] = useState(false);
  const isResizing = useRef(false);
  const [streamingToken, setStreamingToken] = useState(0);

  const [ctxMenu, setCtxMenu] = useState<ContextMenuState | null>(null);

  // mode switching state
  const [isSwitchingMode, setIsSwitchingMode] = useState(false);
  const queuedSwitch = useRef(false);
  const switchStartAt = useRef<number>(0);
  const lastIntentId = useRef<number>(0);
  const MIN_INDICATOR_MS = 420;
  const COOLDOWN_MS = 800;
  const HARD_TIMEOUT_MS = 20_000;

  const activeThread = threadList.find((t) => t.id === activeItem);
  const currentMessages = activeThread?.messages || [];

  // CUT marker on last assistant msg
  const markLastAssistantCut = useCallback(() => {
    if (!activeItem) return;
    const BLOCK = '█';
    setThreadList(prev => {
      const idx = prev.findIndex(t => t.id === activeItem);
      if (idx === -1) return prev;
      const t = prev[idx];
      if (!t.messages.length) return prev;
      const last = t.messages[t.messages.length - 1];
      if (last.sender !== 'Blur') return prev;
      const lastText = (last.text ?? '');
      if (lastText.trimEnd().endsWith(BLOCK)) return prev;
      const updated = [...t.messages];
      updated[updated.length - 1] = { ...last, text: lastText + BLOCK };
      const next = [...prev];
      next[idx] = { ...t, messages: updated };
      return next;
    });
  }, [activeItem, setThreadList]);

  /* ===================== SEND: never gate on activeItem ===================== */
  const handleNewCommandLocal = (command: string) => {
    if (isSwitchingMode) return; // only block during hard mode switch
    // forward with optional hint; App will ensure a thread exists (create/focus)
    onNewCommand(command, activeItem || undefined);
  };

  const toggleSidebar = () => setSidebarCollapsed(!sidebarCollapsed);
  const openSettings = () => setShowSettings(true);
  const closeSettings = () => setShowSettings(false);

  /* ===================== Mode switch visuals ===================== */
  const endSwitchVisual = useCallback(() => {
    const elapsed = Date.now() - switchStartAt.current;
    const remain = Math.max(0, MIN_INDICATOR_MS - elapsed);
    window.setTimeout(() => setIsSwitchingMode(false), remain);
  }, []);

  useEffect(() => {
    if (!isSwitchingMode) return;
    if (connectionStatus === 'ready') endSwitchVisual();
  }, [connectionStatus, isSwitchingMode, endSwitchVisual]);

  useEffect(() => {
    if (!isSwitchingMode) return;
    const onComplete = () => endSwitchVisual();
    const onError = () => endSwitchVisual();
    window.addEventListener('blur:mode-ready', onComplete as EventListener);
    window.addEventListener('blur:mode-switch-complete', onComplete as EventListener);
    window.addEventListener('blur:mode-switch-error', onError as EventListener);
    const hard = window.setTimeout(onError, HARD_TIMEOUT_MS);
    return () => {
      window.removeEventListener('blur:mode-ready', onComplete as EventListener);
      window.removeEventListener('blur:mode-switch-complete', onComplete as EventListener);
      window.removeEventListener('blur:mode-switch-error', onError as EventListener);
      window.clearTimeout(hard);
    };
  }, [isSwitchingMode, endSwitchVisual]);

  const requestModeSwitch = useCallback(() => {
    const now = Date.now();
    if (isSwitchingMode) { queuedSwitch.current = true; return; }
    if (now - (switchStartAt.current || 0) < COOLDOWN_MS) return;

    lastIntentId.current += 1;
    const intentId = lastIntentId.current;
    switchStartAt.current = now;
    setIsSwitchingMode(true);

    try {
      window.dispatchEvent(new CustomEvent('blur:mode-switch-start', { detail: { intentId, from: currentMode } }));
    } catch {}

    try {
      if (isLoading) markLastAssistantCut();
      onStopGeneration();
    } catch {}

    try { onModeToggle(); } catch {}
  }, [currentMode, isSwitchingMode, onModeToggle, onStopGeneration, isLoading, markLastAssistantCut]);

  useEffect(() => {
    if (!isSwitchingMode && queuedSwitch.current) {
      queuedSwitch.current = false;
      const t = window.setTimeout(() => requestModeSwitch(), 50);
      return () => window.clearTimeout(t);
    }
  }, [isSwitchingMode, requestModeSwitch]);

  /* ===================== Resizer ===================== */
  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    const minWidth = 220;
    const maxWidth = Math.round(window.innerWidth / 3);
    const newWidth = e.clientX;
    if (newWidth >= minWidth && newWidth <= maxWidth) setSidebarWidth(newWidth);
  }, []);

  const handleMouseUp = useCallback(() => {
    isResizing.current = false;
    setIsDragging(false);
    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);
    document.body.style.userSelect = 'auto';
  }, [handleMouseMove]);

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault();
      isResizing.current = true;
      setIsDragging(true);
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      document.body.style.userSelect = 'none';
    },
    [handleMouseMove, handleMouseUp]
  );

  useEffect(() => {
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);

  /* ===================== Stream tick for MainContent ===================== */
  useEffect(() => {
    const onChunk = () => setStreamingToken((t) => t + 1);
    window.addEventListener('blur:stream-chunk', onChunk as EventListener);
    return () => window.removeEventListener('blur:stream-chunk', onChunk as EventListener);
  }, []);

  /* ===================== Context menu ===================== */
  const handleThreadContextMenu = useCallback(
    (e: React.MouseEvent, id: string) => {
      e.preventDefault();
      if (id !== activeItem) setActiveItem(id);

      const pad = 8;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const x = Math.min(Math.max(e.clientX, pad), vw - 180);
      const y = Math.min(Math.max(e.clientY, pad), vh - 100);

      setCtxMenu({ visible: true, x, y, itemId: id, itemType: 'thread' });

      if (onThreadContextMenuExternal) {
        try { onThreadContextMenuExternal(e, id); } catch {}
      }
    },
    [activeItem, onThreadContextMenuExternal, setActiveItem]
  );

  useEffect(() => {
    if (!ctxMenu?.visible) return;
    const close = () => setCtxMenu(null);
    window.addEventListener('scroll', close, true);
    window.addEventListener('resize', close);
    return () => {
      window.removeEventListener('scroll', close, true);
      window.removeEventListener('resize', close);
    };
  }, [ctxMenu?.visible]);

  const closeMenu = () => setCtxMenu(null);

  const deleteThread = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    const idx = threadList.findIndex((t) => t.id === id);
    if (idx === -1) return;

    const updated = threadList.filter((t) => t.id !== id);
    setThreadList(updated);

    if (activeItem === id) {
      const fallback = updated[idx] || updated[idx - 1] || updated[0] || null;
      setActiveItem(fallback ? fallback.id : null);
    }
    closeMenu();
  };

  const requestRename = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    if (activeItem !== id) setActiveItem(id);
    window.dispatchEvent(new CustomEvent('blur:rename-request', { detail: { id } }));
    setTimeout(() => { try { renameInputRef?.current?.focus?.(); } catch {} }, 0);
    closeMenu();
  };

  /* ===================== UI Bits ===================== */
  const ModeShimmer = () => (
    <div className="absolute inset-x-0 top-[57px] h-[2px] overflow-hidden">
      <div className={`${isSwitchingMode ? 'animate-[shimmer_1.2s_linear_infinite]' : 'opacity-0'} h-full w-full bg-gradient-to-r from-transparent via-white/70 to-transparent`} />
      <style>{`@keyframes shimmer { 0%{ transform: translateX(-100%);} 100%{ transform: translateX(100%);} }`}</style>
    </div>
  );

  const ModeBadge = () => (
    isSwitchingMode ? (
      <span className="ml-3 inline-flex items-center px-2 py-1 rounded-full border border-white/10 bg-white/5 backdrop-blur-sm select-none">
        <span className="inline-block h-3 w-3 rounded-full border-2 border-white/40 border-t-transparent animate-spin" />
      </span>
    ) : null
  );

  const handleNewConversationLocal = useCallback(() => {
    try {
      if (isLoading) markLastAssistantCut();
      onStopGeneration();
    } catch {}
    onNewConversation();
  }, [isLoading, onStopGeneration, onNewConversation, markLastAssistantCut]);

  /* ===================== Render ===================== */
  return (
    <div className="flex flex-col h-full bg-black relative">
      <ModeShimmer />

      <div className="flex flex-1 overflow-hidden">
        <div
          className={`relative flex-shrink-0 border-r border-zinc-900 ${sidebarCollapsed ? 'w-0 !border-none' : ''} ${!isDragging ? 'transition-all duration-300' : ''}`}
          style={!sidebarCollapsed ? { width: `${sidebarWidth}px` } : {}}
        >
          <div className="h-full w-full overflow-hidden">
            <Sidebar
              activeSection="threads"
              setActiveSection={() => {}}
              activeItem={activeItem}
              setActiveItem={setActiveItem}
              threadList={threadList}
              setThreadList={setThreadList}
              sidebarCollapsed={sidebarCollapsed}
              onNewConversation={handleNewConversationLocal}
              onThreadContextMenu={handleThreadContextMenu}
              renameState={renameState}
              renameInputRef={renameInputRef}
              onRenameChange={onRenameChange}
              onRenameKeyDown={onRenameKeyDown}
              onRenameBlur={onRenameBlur}
            />
          </div>

          {!sidebarCollapsed && (
            <div
              onMouseDown={handleMouseDown}
              className={`absolute top-0 right-[-4px] h-full w-2 z-20 cursor-col-resize transition-colors duration-200 ${isDragging ? 'resizer-ache-glow' : 'hover:resizer-ache-glow'}`}
              title="Resize sidebar"
            />
          )}
        </div>

        <div className="flex-1 flex flex-col overflow-hidden">
          <div className="h-[57px] border-b border-zinc-900 flex items-center justify-between px-4 flex-shrink-0">
            <div className="flex items-center space-x-2">
              <div className="flex items-center justify-center cursor-pointer" onClick={toggleSidebar}>
                <span className="text-3xl text-gray-400 hover:text-white transition-colors duration-150 icon-font mt-[7px]">☾</span>
              </div>
              {sidebarCollapsed && (
                <span className="ml-2">
                  <span className="text-white text-2xl font-bold acheintegrated-glow">∴ blur.</span>
                </span>
              )}
            </div>

            <div className="flex items-center">
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${isSwitchingMode ? 'opacity-50 pointer-events-none' : 'blur-glow-hover'} ${currentMode === 'astrofuck' ? 'mode-astrofuck-active' : ''}`}
                onClick={requestModeSwitch}
                title={isSwitchingMode ? 'Switching…' : 'Switch mode'}
              >
                <span className="text-3xl icon-font">∅</span>
              </div>
              <div className="mode-separator">
                <span className="text-2xl icon-font">|</span>
              </div>
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${isSwitchingMode ? 'opacity-50 pointer-events-none' : (currentMode === 'dream' ? 'mode-dream-active' : 'blur-glow-hover')}`}
                onClick={requestModeSwitch}
                title={isSwitchingMode ? 'Switching…' : 'Switch mode'}
              >
                <span className="text-3xl icon-font">∞</span>
              </div>
              <ModeBadge />
            </div>

            <div className="flex items-center">
              <div className="flex items-center justify-center cursor-pointer" onClick={openSettings}>
                <span className="text-3xl hover:text-white text-gray-400 transition-colors duration-150 icon-font -mt-[3px]">🜃</span>
              </div>
            </div>
          </div>

          <div className="flex-1 min-h-0 overflow-hidden">
            <MainContent messages={currentMessages} streamingToken={streamingToken} />
          </div>

          <div className="mt-auto flex-shrink-0">
            <CommandInput
              // 🚀 Always forward; App will create+focus thread if needed.
              onSendMessage={handleNewCommandLocal}
              connectionStatus={connectionStatus}
              isLoading={isLoading || isSwitchingMode}
              // If your CommandInput supports it, pass the hint too:
              threadId={activeItem || ''}
            />
          </div>
        </div>
      </div>

      {showSettings && <Settings onClose={closeSettings} />}

      {ctxMenu?.visible && (
        <ContextMenu
          x={ctxMenu.x}
          y={ctxMenu.y}
          onClose={closeMenu}
          onDelete={deleteThread}
          onRename={requestRename}
        />
      )}
    </div>
  );
};
