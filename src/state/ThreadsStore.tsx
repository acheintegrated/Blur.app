import React, { createContext, useContext, useEffect, useMemo, useRef, useState } from "react";
import { useSettings } from "../components/SettingsContext";

// Basic shapes — match your app’s message/thread structure
export type Sender = "Blur" | "You" | "System";
export interface Message {
  id: string;
  sender: Sender;
  text: string;
  systemType?: "announcement" | "normal";
  ts?: number;
}
export interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
  createdAt?: number;
  updatedAt?: number;
}

type ThreadsCtx = {
  threads: Thread[];
  activeId?: string;
  setActive: (id?: string) => void;
  createThread: (seed?: Partial<Thread>) => Thread;
  deleteThread: (id: string) => void;
  renameThread: (id: string, title: string) => void;
  appendMessage: (threadId: string, msg: Message) => void;
  replaceAll: (next: Thread[]) => void;
};

const KEY = "threads.v1";
const prefs: any = (window as any)?.prefs;

const ThreadsContext = createContext<ThreadsCtx | undefined>(undefined);

export function ThreadsProvider({ children }: { children: React.ReactNode }) {
  const { settings } = useSettings();
  const [threads, setThreads] = useState<Thread[]>([]);
  const [activeId, setActive] = useState<string | undefined>(undefined);
  const saveTimer = useRef<number | null>(null);

  // Load from disk
  useEffect(() => {
    (async () => {
      try {
        const raw = await prefs?.get?.(KEY, null);
        if (Array.isArray(raw)) {
          setThreads(raw as Thread[]);
          if ((raw as Thread[])[0]) setActive((raw as Thread[])[0].id);
        }
      } catch (e) {
        console.error("[threads] load error", e);
      }
    })();
  }, []);

  // Persistence
  const persistNow = async (next: Thread[]) => {
    try { await prefs?.set?.(KEY, next); } catch (e) { console.error("[threads] save error", e); }
  };

  // Debounced autosave when enabled
  const queueSave = (next: Thread[]) => {
    if (!settings.autoSave) { void persistNow(next); return; }
    const delayMs = Math.max(1, settings.saveInterval) * 60 * 1000;
    if (saveTimer.current) window.clearTimeout(saveTimer.current);
    saveTimer.current = window.setTimeout(() => { void persistNow(next); }, delayMs);
  };

  // Also flush on close
  useEffect(() => {
    const onClose = () => { void persistNow(threads); };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, [threads]);

  const createThread = (seed?: Partial<Thread>): Thread => {
    const t: Thread = {
      id: crypto.randomUUID(),
      title: seed?.title ?? "new conversation",
      autoGenerated: seed?.autoGenerated ?? false,
      messages: seed?.messages ?? [],
      sessionId: seed?.sessionId ?? null,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    setThreads((prev) => {
      const next = [t, ...prev];
      queueSave(next);
      return next;
    });
    setActive(t.id);
    return t;
  };

  const deleteThread = (id: string) => {
    setThreads((prev) => {
      const next = prev.filter((t) => t.id !== id);
      if (activeId === id) setActive(next[0]?.id);
      queueSave(next);
      return next;
    });
  };

  const renameThread = (id: string, title: string) => {
    setThreads((prev) => {
      const next = prev.map((t) => (t.id === id ? { ...t, title, updatedAt: Date.now() } : t));
      queueSave(next);
      return next;
    });
  };

  const appendMessage = (threadId: string, msg: Message) => {
    setThreads((prev) => {
      const next = prev.map((t) =>
        t.id === threadId
          ? { ...t, messages: [...t.messages, { ...msg, ts: msg.ts ?? Date.now() }], updatedAt: Date.now() }
          : t
      );
      queueSave(next);
      return next;
    });
  };

  const replaceAll = (next: Thread[]) => {
    setThreads(next);
    queueSave(next);
  };

  const value = useMemo<ThreadsCtx>(() => ({
    threads, activeId, setActive, createThread, deleteThread, renameThread, appendMessage, replaceAll
  }), [threads, activeId]);

  return <ThreadsContext.Provider value={value}>{children}</ThreadsContext.Provider>;
}

export function useThreads() {
  const v = useContext(ThreadsContext);
  if (!v) throw new Error("useThreads must be used within ThreadsProvider");
  return v;
}
