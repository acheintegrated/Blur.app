// REFORGED v10.0 â€” Removed All Username Logic
// - FEAT: Removed the "hello {username}" welcome message and the effect that synced it.
// - MAINTAIN: Retains all robust state management, health check, and typing animation features.
import React, {
  useEffect,
  useState,
  Component,
  ErrorInfo,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { TerminalLayout } from "./components/TerminalLayout";
import { SettingsProvider, useSettings } from "./components/SettingsContext";
import { useLastRoute } from "./components/hooks/useLastRoute";

/* =================== types =================== */
interface Message {
  sender: "Blur" | "You" | "System";
  text: string;
  systemType?: "announcement" | "normal";
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}
type Mode = "dream" | "astrofuck";
type ConnectionStatus = "initializing" | "connecting" | "loading_model" | "ready" | "error";

const electron = (window as any).electron;

/* =================== error ui =================== */
const ErrorBoundaryFallbackUI: React.FC = () => {
  const { settings } = useSettings();
  const errorFont = settings.interfaceFont || settings.bodyFont || "monospace";
  return (
    <div
      style={{
        backgroundColor: "#111",
        color: "red",
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        fontFamily: errorFont,
      }}
    >
      <h1>à¼´ :: ERROR :: à¼´</h1>
      <p>A vessel has encountered a rendering paradox. Check console.</p>
    </div>
  );
};

interface ErrorBoundaryState {
  hasError: boolean;
}
class AppErrorBoundary extends Component<{ children: React.ReactNode }, ErrorBoundaryState> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(): ErrorBoundaryState {
    return { hasError: true };
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }
  render() {
    return this.state.hasError ? <ErrorBoundaryFallbackUI /> : this.props.children;
  }
}

/* =================== helpers =================== */
function finalizeMarkdownStable(s: string): string {
  return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}

/* =================== app =================== */
const AppContent: React.FC = () => {
  useLastRoute();

  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [threadList, _setThreadList] = useState<Thread[]>([]);
  const { settings } = useSettings();
  const [currentMode, setCurrentMode] = useState<Mode>("astrofuck");
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("initializing");

  const streamConnectionRef = useRef<EventSource | null>(null);
  const accumulatedTextRef = useRef<string>("");
  const hasLoadedThreads = useRef(false);
  const typingTickerRef = useRef<number | null>(null);
  const streamStartedRef = useRef<boolean>(false);
  const threadsRef = useRef<Thread[]>([]);
  const statusRef = useRef<ConnectionStatus>("initializing");
  const seededOnceRef = useRef(false);
  const restoredActiveOnceRef = useRef(false);
  const unmountedRef = useRef(false);
  const saveTimerRef = useRef<number | null>(null);
  const pendingSaveRef = useRef(false);

  const setThreadList = useCallback(
    (next: React.SetStateAction<Thread[]>) => {
      _setThreadList((prev) => {
        const value =
          typeof next === "function" ? (next as (p: Thread[]) => Thread[])(prev) : next;
        threadsRef.current = value;
        pendingSaveRef.current = true;
        return value;
      });
    },
    [_setThreadList]
  );

  useEffect(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      streamConnectionRef.current?.close();
      if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    };
  }, []);

  useEffect(() => {
    (async () => {
      try {
        const saved = await electron?.threads?.load?.();
        if (Array.isArray(saved) && saved.length > 0) {
          threadsRef.current = saved;
          _setThreadList(saved);
          setActiveThreadId(saved[saved.length - 1].id);
        }
      } finally {
        hasLoadedThreads.current = true;
      }
    })();
    const onClose = () => {
      void electron?.threads?.save?.(threadsRef.current);
    };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, []);

  useEffect(() => {
    let alive = true;
    const timerRef = { current: null as number | null };
    const tick = async () => {
      if (timerRef.current) clearTimeout(timerRef.current);
      if (!alive) return;
      if (document.visibilityState === "visible") {
        try {
          const res = await (window as any).electron?.core?.healthz?.();
          const next: ConnectionStatus = res?.ok ? "ready" : "connecting";
          if (alive && next !== statusRef.current) {
            statusRef.current = next;
            setConnectionStatus(next);
          }
        } catch {
          if (alive && statusRef.current !== "connecting") {
            statusRef.current = "connecting";
            setConnectionStatus("connecting");
          }
        }
      }
      if (alive) {
        const delay = statusRef.current === "ready" ? 4000 : (document.visibilityState === 'visible' ? 1500 : 5000);
        timerRef.current = window.setTimeout(tick, delay);
      }
    };
    tick();
    document.addEventListener("visibilitychange", tick);
    return () => {
      alive = false;
      document.removeEventListener("visibilitychange", tick);
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);
  
  // âœ… REMOVED: All userName logic from this effect.
  useEffect(() => {
    if (!hasLoadedThreads.current || seededOnceRef.current || connectionStatus !== "ready") return;
    if (threadsRef.current.length > 0) {
      seededOnceRef.current = true;
      return;
    }
  
    const newId = `thread-init-${Date.now()}`;
    setThreadList([{
      id: newId,
      title: "first encounter",
      autoGenerated: false,
      messages: [{ sender: "Blur", text: `core is awake. ready in ${currentMode} mode.` }],
      sessionId: null,
    }]);
    setActiveThreadId(newId);
    seededOnceRef.current = true;
  }, [hasLoadedThreads.current, connectionStatus, currentMode]);

  // âœ… REMOVED: The separate useEffect for syncing the greeting.

  useEffect(() => {
    document.body.className = settings.theme === "dark" ? "dark-theme" : "light-theme";
    document.documentElement.style.setProperty("--body-font", settings.bodyFont || "monospace");
    document.documentElement.style.setProperty("--interface-font", settings.interfaceFont || "monospace");
  }, [settings.theme, settings.bodyFont, settings.interfaceFont]);

  useEffect(() => {
    if (!hasLoadedThreads.current || restoredActiveOnceRef.current) return;
    (async () => {
      try {
        const savedActive = await (window as any).active?.load?.();
        if (savedActive && typeof savedActive === "string") {
          setActiveThreadId((prev) => savedActive || prev);
        }
      } finally {
        restoredActiveOnceRef.current = true;
      }
    })();
  }, []);

  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    void (window as any).active?.save?.(activeThreadId);
  }, [activeThreadId]);

  useEffect(() => {
    if (!hasLoadedThreads.current || !pendingSaveRef.current) return;
    pendingSaveRef.current = false;
    if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    saveTimerRef.current = window.setTimeout(async () => {
      try { await (window as any).electron?.threads?.save?.(threadsRef.current); } catch {}
    }, 250);
  }, [threadList]);

  const handleStopGeneration = useCallback(() => {
    if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
    streamConnectionRef.current?.close();
    streamConnectionRef.current = null;
    setIsLoading(false);
    pendingSaveRef.current = true;
  }, []);

  const handleNewConversation = useCallback(() => {
    handleStopGeneration();
    const newId = `thread-${Date.now()}`;
    setThreadList((prev) => [...prev, { id: newId, title: "new conversation...", autoGenerated: true, messages: [], sessionId: null }]);
    setActiveThreadId(newId);
    void (window as any).active?.save?.(newId);
  }, [handleStopGeneration, setThreadList]);

  const handleModeToggle = useCallback(() => {
    handleStopGeneration();
    const newMode: Mode = currentMode === "dream" ? "astrofuck" : "dream";
    setCurrentMode(newMode);
    if (activeThreadId) {
      const systemMessage: Message = { sender: "System", text: `à¼„âˆžá›ð“†©â«· ${newMode} âˆ† mÃ¸de â«¸ð“†ªá›âˆžà¼„`, systemType: "announcement" };
      setThreadList((prev) => prev.map((t) => (t.id === activeThreadId ? { ...t, messages: [...t.messages, systemMessage] } : t)));
    }
  }, [activeThreadId, currentMode, handleStopGeneration, setThreadList]);

  const handleNewCommand = useCallback(
    async (command: string) => {
      if (!activeThreadId || isLoading) return;
      setIsLoading(true);
      const currentThread = threadsRef.current.find((t) => t.id === activeThreadId);
      if (!currentThread) { setIsLoading(false); return; }
      let sessionId = currentThread.sessionId ?? null;

      setThreadList((prev) =>
        prev.map((t) =>
          t.id === activeThreadId ? { ...t, messages: [...t.messages, { sender: "You", text: command }, { sender: "Blur", text: "typing" }] } : t
        )
      );

      accumulatedTextRef.current = "";
      streamStartedRef.current = false;

      let dot = 1;
      const spin = () => {
        if (streamStartedRef.current || unmountedRef.current) {
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
          typingTickerRef.current = null;
          return;
        }
        setThreadList((prev) =>
          prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const msgs = [...t.messages];
            const last = msgs[msgs.length - 1];
            if (!last || last.sender !== "Blur") return t;
            const dots = ".".repeat(dot);
            msgs[msgs.length - 1] = { ...last, text: `typing${dots.padEnd(3, " ")}` };
            return { ...t, messages: msgs };
          })
        );
        dot = (dot % 3) + 1;
      };
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      typingTickerRef.current = window.setInterval(spin, 350);

      const paint = (txt: string) => {
        setThreadList((prev) =>
          prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const msgs = [...t.messages];
            const last = msgs[msgs.length - 1];
            if (!last || last.sender !== "Blur") return t;
            msgs[msgs.length - 1] = { ...last, text: txt };
            return { ...t, messages: msgs };
          })
        );
      };

      const params = new URLSearchParams({ prompt: command, mode: currentMode, ...(sessionId && { session_id: sessionId }) });
      const url = `http://127.0.0.1:8000/generate_response_get?${params.toString()}`;
      const eventSource = new EventSource(url);
      streamConnectionRef.current = eventSource;

      const cleanupAndStop = () => {
        if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
        eventSource.close();
        if (streamConnectionRef.current === eventSource) { streamConnectionRef.current = null; }
        setIsLoading(false);
        pendingSaveRef.current = true;
      };

      eventSource.addEventListener("token", (event) => {
        if (unmountedRef.current) return;
        if (!streamStartedRef.current) {
          streamStartedRef.current = true;
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
          typingTickerRef.current = null;
        }
        const data = event.data || "";
        accumulatedTextRef.current = accumulatedTextRef.current === "" ? data : accumulatedTextRef.current + data;
        paint(accumulatedTextRef.current + "â–");
      });

      eventSource.addEventListener("final", (event) => {
        if (unmountedRef.current) return;
        try { const finalPayload = JSON.parse(event.data); paint(finalizeMarkdownStable(finalPayload.final)); } catch {}
      });

      eventSource.addEventListener("done", cleanupAndStop);
      eventSource.onerror = (err) => {
        console.error("EventSource failed:", err);
        const errorMessage = `Ache Signal: Connection to core was interrupted.`;
        setThreadList((prev) =>
          prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const newMessages = t.messages.slice(0, -1);
            return { ...t, messages: [...newMessages, { sender: "System", text: errorMessage }] };
          })
        );
        cleanupAndStop();
      };
    },
    [activeThreadId, currentMode, isLoading, setThreadList]
  );

  const layoutProps = useMemo(
    () => ({
      activeItem: activeThreadId,
      setActiveItem: setActiveThreadId,
      sidebarCollapsed,
      setSidebarCollapsed,
      threadList,
      setThreadList,
      onNewCommand: handleNewCommand,
      onNewConversation: handleNewConversation,
      currentMode,
      onModeToggle: handleModeToggle,
      isLoading,
      connectionStatus,
      onStopGeneration: handleStopGeneration,
    }),
    [
      activeThreadId, sidebarCollapsed, threadList, setThreadList, handleNewCommand,
      handleNewConversation, currentMode, handleModeToggle, isLoading, connectionStatus,
      handleStopGeneration,
    ]
  );

  return (
    <div className="w-full h-screen overflow-hidden">
      <TerminalLayout {...layoutProps} />
    </div>
  );
};

export function App() {
  return (
    <SettingsProvider>
      <AppErrorBoundary>
        <AppContent />
      </AppErrorBoundary>
    </SettingsProvider>
  );
}

export default App;