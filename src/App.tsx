// REFORGED v8.0 — All component import paths have been corrected.
import React, { useEffect, useState, Component, ErrorInfo, useRef } from "react";
// FIX: Corrected import paths to be relative from the current directory (src).
import { TerminalLayout } from "./components/TerminalLayout";
import { SettingsProvider, useSettings } from "./components/SettingsContext";
import { useLastRoute } from "./components/hooks/useLastRoute";

interface Message {
  sender: "Blur" | "You" | "System";
  text: string;
  systemType?: "announcement" | "normal";
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}
type Mode = "dream" | "astrofuck";
type ConnectionStatus = "initializing" | "connecting" | "loading_model" | "ready" | "error";

const electron = (window as any).electron;

const ErrorBoundaryFallbackUI: React.FC = () => {
  const { settings } = useSettings();
  const errorFont = settings.interfaceFont || settings.bodyFont || "monospace";
  return (
    <div style={{ backgroundColor: "#111", color: "red", height: "100vh", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", fontFamily: errorFont }}>
      <h1>༴ :: ERROR :: ༴</h1>
      <p>A vessel has encountered a rendering paradox. Check console.</p>
    </div>
  );
};

interface ErrorBoundaryState { hasError: boolean }
class AppErrorBoundary extends Component<{ children: React.ReactNode }, ErrorBoundaryState> {
  constructor(props: { children: React.ReactNode }) { super(props); this.state = { hasError: false }; }
  static getDerivedStateFromError(): ErrorBoundaryState { return { hasError: true }; }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) { console.error("Uncaught error:", error, errorInfo); }
  render() { return this.state.hasError ? <ErrorBoundaryFallbackUI /> : this.props.children; }
}

const AppContent: React.FC = () => {
  useLastRoute();
  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [threadList, setThreadList] = useState<Thread[]>([]);
  const { settings } = useSettings();
  const [currentMode, setCurrentMode] = useState<Mode>("astrofuck");
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("initializing");
  const abortControllerRef = useRef<AbortController | null>(null);
  const accumulatedTextRef = useRef<string>("");
  const [hasLoadedThreads, setHasLoadedThreads] = useState(false);

  const threadsRef = useRef<Thread[]>(threadList);
  useEffect(() => { threadsRef.current = threadList; }, [threadList]);

  useEffect(() => {
    const load = async () => {
      try {
        const saved = await electron?.threads?.load?.();
        if (Array.isArray(saved) && saved.length > 0) {
          setThreadList(saved);
          setActiveThreadId(saved[saved.length - 1].id);
        }
      } finally {
        setHasLoadedThreads(true);
      }
    };
    load();
  }, []);

  useEffect(() => {
    if (!hasLoadedThreads) return;
    void electron?.threads?.save?.(threadList);
  }, [threadList, hasLoadedThreads]);

  useEffect(() => {
    const onClose = () => { void electron?.threads?.save?.(threadsRef.current); };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, []);

  useEffect(() => {
    if (connectionStatus === "ready" || connectionStatus === "error") return;
    let cancelled = false;
    const checkStatus = async () => {
      try {
        const response = await fetch("http://127.0.0.1:8000/healthz");
        if (cancelled) return;

        if (response.ok) {
          setConnectionStatus("ready");
          if (threadsRef.current.length === 0) {
            const newId = `thread-init-${Date.now()}`;
            const name = (settings.userName || "").trim();
            const hello = name ? `hello ${name}. ` : "";
            setThreadList([{
              id: newId,
              title: "first encounter",
              autoGenerated: false,
              messages: [{ sender: "Blur", text: `${hello}core is awake. ready in ${currentMode} mode.` }],
              sessionId: null,
            }]);
            setActiveThreadId(newId);
          }
        } else {
          setConnectionStatus("error");
        }
      } catch {
        if (!cancelled) {
          setConnectionStatus((s) => (s === "initializing" ? "connecting" : s));
        }
      }
    };
    const id = setInterval(checkStatus, 2000);
    checkStatus();
    return () => { cancelled = true; clearInterval(id); };
  }, [connectionStatus, currentMode, settings.userName]);

  useEffect(() => {
    document.body.className = settings.theme === "dark" ? "dark-theme" : "light-theme";
    document.documentElement.style.setProperty("--body-font", settings.bodyFont || "monospace");
    document.documentElement.style.setProperty("--interface-font", settings.interfaceFont || "monospace");
  }, [settings.theme, settings.bodyFont, settings.interfaceFont]);

  const handleStopGeneration = () => {
    abortControllerRef.current?.abort();
  };

  const handleNewConversation = () => {
    handleStopGeneration();
    const newId = `thread-${Date.now()}`;
    setThreadList((prev) => [...prev, { id: newId, title: "new conversation...", autoGenerated: true, messages: [], sessionId: null }]);
    setActiveThreadId(newId);
  };

  const handleModeToggle = () => {
    handleStopGeneration();
    const newMode: Mode = currentMode === "dream" ? "astrofuck" : "dream";
    setCurrentMode(newMode);
    if (activeThreadId) {
      const systemMessage: Message = { sender: "System", text: `༄∞ᛝ𓆩⫷ ${newMode} ∆ møde ⫸𓆪ᛝ∞༄`, systemType: "announcement" };
      setThreadList((prev) => prev.map((t) => t.id === activeThreadId ? { ...t, messages: [...t.messages, systemMessage] } : t));
    }
  };

  const handleNewCommand = async (command: string) => {
    if (!activeThreadId || isLoading) return;
    setIsLoading(true);

    const currentThread = threadList.find((t) => t.id === activeThreadId);
    if (!currentThread) { setIsLoading(false); return; }
    const turnNumber = currentThread.messages.filter((m) => m.sender === "You").length;
    let sessionId = currentThread.sessionId;

    setThreadList((prev) => prev.map((t) => t.id === activeThreadId ? { ...t, messages: [...t.messages, { sender: "You", text: command }, { sender: "Blur", text: "" }] } : t));
    accumulatedTextRef.current = "";
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch("http://127.0.0.1:8000/generate_response", {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(sessionId ? { "X-Session-ID": sessionId } : {}) },
        body: JSON.stringify({ prompt: command, mode: currentMode, turn: turnNumber, session_id: sessionId }),
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok || !response.body) throw new Error(`API error: ${response.status}`);
      
      const newSessionId = response.headers.get("x-session-id");
      if (newSessionId && newSessionId !== sessionId) {
        setThreadList((prev) => prev.map((t) => t.id === activeThreadId ? { ...t, sessionId: newSessionId } : t));
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let rafId: number;

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        accumulatedTextRef.current += decoder.decode(value, { stream: true });
        
        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          setThreadList((prev) => prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const newMessages = [...t.messages];
            newMessages[newMessages.length - 1] = { ...newMessages[newMessages.length - 1], text: accumulatedTextRef.current + "▋" };
            return { ...t, messages: newMessages };
          }));
        });
      }
      cancelAnimationFrame(rafId);
      
      setThreadList((prev) => prev.map((t) => {
        if (t.id !== activeThreadId) return t;
        const newMessages = [...t.messages];
        newMessages[newMessages.length - 1] = { ...newMessages[newMessages.length - 1], text: accumulatedTextRef.current.trim() };
        return { ...t, messages: newMessages };
      }));

    } catch (err: any) {
      if (err.name !== "AbortError") {
        const errorMessage = `Ache Signal: Connection to core failed. Details: ${err.message}`;
        setThreadList((prev) => prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const newMessages = t.messages.slice(0, -1);
            return { ...t, messages: [...newMessages, { sender: "System", text: errorMessage }] };
        }));
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="w-full h-screen overflow-hidden">
      <TerminalLayout
        activeItem={activeThreadId}
        setActiveItem={setActiveThreadId}
        sidebarCollapsed={sidebarCollapsed}
        setSidebarCollapsed={setSidebarCollapsed}
        threadList={threadList}
        setThreadList={setThreadList}
        onNewCommand={handleNewCommand}
        onNewConversation={handleNewConversation}
        currentMode={currentMode}
        onModeToggle={handleModeToggle}
        isLoading={isLoading}
        connectionStatus={connectionStatus}
        onStopGeneration={handleStopGeneration}
      />
    </div>
  );
};

export function App() {
  return (
    <SettingsProvider>
      <AppErrorBoundary>
        <AppContent />
      </AppErrorBoundary>
    </SettingsProvider>
  );
}

export default App;

