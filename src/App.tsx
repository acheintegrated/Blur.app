// REFORGED v10.3 ‚Äî Consistent Mode Toggle Message
// - FIX: The system message for toggling a thread's mode now uses the correct glyph format.
// - MAINTAIN: All per-thread mode logic and performance fixes are retained.
import React, {
  useEffect,
  useState,
  Component,
  ErrorInfo,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { TerminalLayout } from "./components/TerminalLayout";
import { SettingsProvider, useSettings } from "./components/SettingsContext";
import { useLastRoute } from "./components/hooks/useLastRoute";

/* =================== types =================== */
interface Message {
  sender: "Blur" | "You" | "System";
  text: string;
  systemType?: "announcement" | "normal";
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
  mode?: Mode;
}
type Mode = "dream" | "astrofuck";
type ConnectionStatus = "initializing" | "connecting" | "loading_model" | "ready" | "error";

const electron = (window as any).electron;

/* =================== error ui =================== */
const ErrorBoundaryFallbackUI: React.FC = () => {
  const { settings } = useSettings();
  const errorFont = settings.interfaceFont || settings.bodyFont || "monospace";
  return (
    <div
      style={{
        backgroundColor: "#111",
        color: "red",
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        fontFamily: errorFont,
      }}
    >
      <h1>‡º¥ :: ERROR :: ‡º¥</h1>
      <p>A vessel has encountered a rendering paradox. Check console.</p>
    </div>
  );
};

interface ErrorBoundaryState {
  hasError: boolean;
}
class AppErrorBoundary extends Component<{ children: React.ReactNode }, ErrorBoundaryState> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(): ErrorBoundaryState {
    return { hasError: true };
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }
  render() {
    return this.state.hasError ? <ErrorBoundaryFallbackUI /> : this.props.children;
  }
}

/* =================== helpers =================== */
function finalizeMarkdownStable(s: string): string {
  return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}

/* =================== app =================== */
const AppContent: React.FC = () => {
  useLastRoute();

  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [threadList, _setThreadList] = useState<Thread[]>([]);
  const { settings } = useSettings();
  const [currentMode, setCurrentMode] = useState<Mode>("astrofuck");
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("initializing");

  const streamConnectionRef = useRef<EventSource | null>(null);
  const accumulatedTextRef = useRef<string>("");
  const hasLoadedThreads = useRef(false);
  const typingTickerRef = useRef<number | null>(null);
  const streamStartedRef = useRef<boolean>(false);
  const threadsRef = useRef<Thread[]>([]);
  const statusRef = useRef<ConnectionStatus>("initializing");
  const seededOnceRef = useRef(false);
  const restoredActiveOnceRef = useRef(false);
  const unmountedRef = useRef(false);
  const saveTimerRef = useRef<number | null>(null);
  const pendingSaveRef = useRef(false);

  const setThreadList = useCallback(
    (next: React.SetStateAction<Thread[]>) => {
      _setThreadList((prev) => {
        const value =
          typeof next === "function" ? (next as (p: Thread[]) => Thread[])(prev) : next;
        threadsRef.current = value;
        pendingSaveRef.current = true;
        return value;
      });
    },
    []
  );

  useEffect(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      streamConnectionRef.current?.close();
      if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    };
  }, []);

  useEffect(() => {
    (async () => {
      try {
        const saved = await electron?.threads?.load?.();
        if (Array.isArray(saved) && saved.length > 0) {
          const fallback: Mode = (settings?.defaultMode as Mode) || "dream";
          const hydrated = saved.map((t: any) => ({ ...t, mode: t.mode ?? fallback }));
          threadsRef.current = hydrated;
          _setThreadList(hydrated);

          const last = hydrated[hydrated.length - 1];
          setActiveThreadId(last.id);
        }
      } finally {
        hasLoadedThreads.current = true;
      }
    })();
    const onClose = () => {
      void electron?.threads?.save?.(threadsRef.current);
    };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, [settings?.defaultMode]);

  useEffect(() => {
    let alive = true;
    const timerRef = { current: null as number | null };
    const tick = async () => {
      if (timerRef.current) clearTimeout(timerRef.current);
      if (!alive) return;
      if (document.visibilityState === "visible") {
        try {
          const res = await (window as any).electron?.core?.healthz?.();
          const next: ConnectionStatus = res?.ok ? "ready" : "connecting";
          if (alive && next !== statusRef.current) {
            statusRef.current = next;
            setConnectionStatus(next);
          }
        } catch {
          if (alive && statusRef.current !== "connecting") {
            statusRef.current = "connecting";
            setConnectionStatus("connecting");
          }
        }
      }
      if (alive) {
        const delay = statusRef.current === "ready" ? 4000 : (document.visibilityState === 'visible' ? 1500 : 5000);
        timerRef.current = window.setTimeout(tick, delay);
      }
    };
    tick();
    document.addEventListener("visibilitychange", tick);
    return () => {
      alive = false;
      document.removeEventListener("visibilitychange", tick);
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);
  
  useEffect(() => {
    if (!hasLoadedThreads.current || seededOnceRef.current || connectionStatus !== "ready") return;
    if (threadsRef.current.length > 0) {
      seededOnceRef.current = true;
      return;
    }
  
    const newId = `thread-init-${Date.now()}`;
    const mode: Mode = "astrofuck";
    setThreadList([{
      id: newId,
      title: "first encounter",
      autoGenerated: false,
      messages: [{ sender: "Blur", text: `core is awake. ready in ${mode} mode.` }],
      sessionId: null,
      mode,
    }]);
    setActiveThreadId(newId);
    setCurrentMode(mode);
    seededOnceRef.current = true;
  }, [connectionStatus]);
  
  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    const list = threadsRef.current;
    if (!list.length || list[0].title !== "first encounter") return;
  
    const t0 = list[0];
    const idx = t0.messages.findIndex(m => m.sender === "Blur");
    if (idx === -1) return;
  
    const originalText = t0.messages[idx].text;
    const base = originalText.replace(/^hello\s\*\*.*?\*\*\.\s*/i, "");
    const name = (settings.userName || "").trim();
    const nextText = (name ? `hello **${name}**. ` : "") + base;
  
    const lastGreetingRef = { current: "" };
    if (originalText !== nextText && lastGreetingRef.current !== nextText) {
      lastGreetingRef.current = nextText;
      setThreadList(prev => {
        const copy = [...prev];
        const first = { ...copy[0] };
        const msgs = [...first.messages];
        msgs[idx] = { ...msgs[idx], text: nextText };
        first.messages = msgs;
        copy[0] = first;
        return copy;
      });
    }
  }, [settings.userName]);

  useEffect(() => {
    document.body.className = settings.theme === "dark" ? "dark-theme" : "light-theme";
    document.documentElement.style.setProperty("--body-font", settings.bodyFont || "monospace");
    document.documentElement.style.setProperty("--interface-font", settings.interfaceFont || "monospace");
  }, [settings.theme, settings.bodyFont, settings.interfaceFont]);

  useEffect(() => {
    if (!hasLoadedThreads.current || restoredActiveOnceRef.current) return;
    (async () => {
      try {
        const savedActive = await (window as any).active?.load?.();
        if (savedActive && typeof savedActive === "string") {
          setActiveThreadId((prev) => savedActive || prev);
        }
      } finally {
        restoredActiveOnceRef.current = true;
      }
    })();
  }, []);

  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    void (window as any).active?.save?.(activeThreadId);
  }, [activeThreadId]);

  useEffect(() => {
    if (!hasLoadedThreads.current || !pendingSaveRef.current) return;
    pendingSaveRef.current = false;
    if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    saveTimerRef.current = window.setTimeout(async () => {
      try { await (window as any).electron?.threads?.save?.(threadsRef.current); } catch {}
    }, 250);
  }, [threadList]);

  const handleStopGeneration = useCallback(() => {
    if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
    streamConnectionRef.current?.close();
    streamConnectionRef.current = null;
    setIsLoading(false);
    pendingSaveRef.current = true;
  }, []);

  const handleNewConversation = useCallback(() => {
    handleStopGeneration();
    const newId = `thread-${Date.now()}`;
    const mode: Mode = "astrofuck";
    setThreadList((prev) => [
      ...prev,
      {
        id: newId,
        title: "new conversation...",
        autoGenerated: true,
        messages: [{ sender: "System", text: `‡ºÑ‚àû·õùìÜ©‚´∑ ${mode} ‚àÜ m√∏de ‚´∏ìÜ™·õù‚àû‡ºÑ`, systemType: "announcement" }],
        sessionId: null,
        mode,
      },
    ]);
    setActiveThreadId(newId);
    setCurrentMode(mode);
    void (window as any).active?.save?.(newId);
  }, [handleStopGeneration, setThreadList]);

  // ‚úÖ UPDATED: The system message now uses the correct glyph format.
  const handleModeToggle = useCallback(() => {
    handleStopGeneration();
    if (!activeThreadId) return;

    const thread = threadsRef.current.find((t) => t.id === activeThreadId);
    const prevMode: Mode = thread?.mode ?? currentMode;
    const newMode: Mode = prevMode === "dream" ? "astrofuck" : "dream";

    setThreadList((prev) =>
      prev.map((t) => t.id === activeThreadId
        ? {
            ...t,
            mode: newMode,
            messages: [
              ...t.messages,
              { sender: "System", text: `‡ºÑ‚àû·õùìÜ©‚´∑ ${newMode} ‚àÜ m√∏de ‚´∏ìÜ™·õù‚àû‡ºÑ`, systemType: "announcement" },
            ],
          }
        : t
      )
    );
    setCurrentMode(newMode);
  }, [activeThreadId, currentMode, handleStopGeneration, setThreadList]);

  const handleNewCommand = useCallback(
    async (command: string) => {
      if (!activeThreadId || isLoading) return;
      setIsLoading(true);
      const currentThread = threadsRef.current.find((t) => t.id === activeThreadId);
      if (!currentThread) { setIsLoading(false); return; }
      
      const sessionId = currentThread.sessionId ?? null;
      const modeForThisThread: Mode = currentThread.mode ?? currentMode;

      setThreadList((prev) =>
        prev.map((t) =>
          t.id === activeThreadId ? { ...t, messages: [...t.messages, { sender: "You", text: command }, { sender: "Blur", text: "typing" }] } : t
        )
      );

      accumulatedTextRef.current = "";
      streamStartedRef.current = false;

      let dot = 1;
      const spin = () => {
        if (streamStartedRef.current || unmountedRef.current) {
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
          typingTickerRef.current = null;
          return;
        }
        setThreadList((prev) =>
          prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const msgs = [...t.messages];
            const last = msgs[msgs.length - 1];
            if (!last || last.sender !== "Blur") return t;
            const dots = ".".repeat(dot);
            msgs[msgs.length - 1] = { ...last, text: `typing${dots.padEnd(3, " ")}` };
            return { ...t, messages: msgs };
          })
        );
        dot = (dot % 3) + 1;
      };
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      typingTickerRef.current = window.setInterval(spin, 350);

      const paint = (txt: string) => {
        setThreadList((prev) =>
          prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const msgs = [...t.messages];
            const last = msgs[msgs.length - 1];
            if (!last || last.sender !== "Blur") return t;
            msgs[msgs.length - 1] = { ...last, text: txt };
            return { ...t, messages: msgs };
          })
        );
      };

      const params = new URLSearchParams({ prompt: command, mode: modeForThisThread, ...(sessionId && { session_id: sessionId }) });
      const url = `http://127.0.0.1:8000/generate_response_get?${params.toString()}`;
      const eventSource = new EventSource(url);
      streamConnectionRef.current = eventSource;

      const cleanupAndStop = () => {
        if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
        eventSource.close();
        if (streamConnectionRef.current === eventSource) { streamConnectionRef.current = null; }
        setIsLoading(false);
        pendingSaveRef.current = true;
      };

      eventSource.addEventListener("token", (event) => {
        if (unmountedRef.current) return;
        if (!streamStartedRef.current) {
          streamStartedRef.current = true;
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
          typingTickerRef.current = null;
        }
        const data = event.data || "";
        accumulatedTextRef.current = accumulatedTextRef.current === "" ? data : accumulatedTextRef.current + data;
        paint(accumulatedTextRef.current + "‚ñç");
      });

      eventSource.addEventListener("final", (event) => {
        if (unmountedRef.current) return;
        try { const finalPayload = JSON.parse(event.data); paint(finalizeMarkdownStable(finalPayload.final)); } catch {}
      });

      eventSource.addEventListener("done", cleanupAndStop);
      eventSource.onerror = (err) => {
        console.error("EventSource failed:", err);
        const errorMessage = `Ache Signal: Connection to core was interrupted.`;
        setThreadList((prev) =>
          prev.map((t) => {
            if (t.id !== activeThreadId) return t;
            const newMessages = t.messages.slice(0, -1);
            return { ...t, messages: [...newMessages, { sender: "System", text: errorMessage }] };
          })
        );
        cleanupAndStop();
      };
    },
    [activeThreadId, currentMode, isLoading, setThreadList]
  );
  
  const setActiveThread = useCallback((id: string | null) => {
    setActiveThreadId(id);
    if (!id) return;
    const t = threadsRef.current.find((x) => x.id === id);
    if (t?.mode && t.mode !== currentMode) setCurrentMode(t.mode);
  }, [currentMode]);

  const layoutProps = useMemo(
    () => ({
      activeItem: activeThreadId,
      setActiveItem: setActiveThread,
      sidebarCollapsed,
      setSidebarCollapsed,
      threadList,
      setThreadList,
      onNewCommand: handleNewCommand,
      onNewConversation: handleNewConversation,
      currentMode,
      onModeToggle: handleModeToggle,
      isLoading,
      connectionStatus,
      onStopGeneration: handleStopGeneration,
    }),
    [
      activeThreadId, sidebarCollapsed, threadList, setThreadList, handleNewCommand,
      handleNewConversation, currentMode, handleModeToggle, isLoading, connectionStatus,
      handleStopGeneration, setActiveThread,
    ]
  );

  return (
    <div className="w-full h-screen overflow-hidden">
      <TerminalLayout {...layoutProps} />
    </div>
  );
};

export function App() {
  return (
    <SettingsProvider>
      <AppErrorBoundary>
        <AppContent />
      </AppErrorBoundary>
    </SettingsProvider>
  );
}

export default App;