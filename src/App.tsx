// REFORGED v10.9 — Voidless Send
// - GUARANTEE: Typing on an empty slate auto-creates + activates a thread before streaming.
// - STABILITY: No UI gating required in TerminalLayout; App owns creation.
// - SAVE: Debounced thread saves unchanged.

import React, {
  useEffect,
  useState,
  Component,
  ErrorInfo,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { TerminalLayout } from "./components/TerminalLayout";
import { SettingsProvider, useSettings } from "./components/SettingsContext";
import { useLastRoute } from "./components/hooks/useLastRoute";

interface Message {
  sender: "Blur" | "You" | "System";
  text: string;
  systemType?: "announcement" | "normal";
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
  mode?: Mode;
}
type Mode = "dream" | "astrofuck";
type ConnectionStatus = "initializing" | "connecting" | "loading_model" | "ready" | "error";

const electron = (window as any).electron;

/* =================== error ui =================== */
const ErrorBoundaryFallbackUI: React.FC = () => {
  const { settings } = useSettings();
  const errorFont = settings.interfaceFont || settings.bodyFont || "monospace";
  return (
    <div
      style={{
        backgroundColor: "#111",
        color: "red",
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        fontFamily: errorFont,
      }}
    >
      <h1>༴ :: ERROR :: ༴</h1>
      <p>A vessel has encountered a rendering paradox. Check console.</p>
    </div>
  );
};

interface ErrorBoundaryState { hasError: boolean; }
class AppErrorBoundary extends Component<{ children: React.ReactNode }, ErrorBoundaryState> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(): ErrorBoundaryState { return { hasError: true }; }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) { console.error("Uncaught error:", error, errorInfo); }
  render() { return this.state.hasError ? <ErrorBoundaryFallbackUI /> : this.props.children; }
}

/* =================== helpers =================== */
function finalizeMarkdownStable(s: string): string {
  return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}

const prepareNewThread = (): Thread => {
  const newId = `thread-${Date.now()}`;
  const mode: Mode = "astrofuck";
  return {
    id: newId,
    title: "new conversation...",
    autoGenerated: true,
    messages: [{ sender: "System", text: `༄∞ᛝ𓆩⫷ ${mode} ∆ møde ⫸𓆪ᛝ∞༄`, systemType: "announcement" }],
    sessionId: null,
    mode,
  };
};

/* =================== app =================== */
const AppContent: React.FC = () => {
  useLastRoute();

  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [threadList, _setThreadList] = useState<Thread[]>([]);
  const { settings } = useSettings();
  const [currentMode, setCurrentMode] = useState<Mode>("astrofuck");
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("initializing");

  const streamConnectionRef = useRef<EventSource | null>(null);
  const accumulatedTextRef = useRef<string>("");
  const hasLoadedThreads = useRef(false);
  const typingTickerRef = useRef<number | null>(null);
  const streamStartedRef = useRef<boolean>(false);
  const threadsRef = useRef<Thread[]>([]);
  const statusRef = useRef<ConnectionStatus>("initializing");
  const seededOnceRef = useRef(false);
  const restoredActiveOnceRef = useRef(false);
  const unmountedRef = useRef(false);
  const saveTimerRef = useRef<number | null>(null);
  const pendingSaveRef = useRef(false);

  const setThreadList = useCallback(
    (next: React.SetStateAction<Thread[]>) => {
      _setThreadList((prev) => {
        const value =
          typeof next === "function" ? (next as (p: Thread[]) => Thread[])(prev) : next;
        threadsRef.current = value;
        return value;
      });
    },
    []
  );

  useEffect(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      streamConnectionRef.current?.close();
      if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    };
  }, []);

  // Load persisted threads
  useEffect(() => {
    (async () => {
      try {
        const saved = await electron?.threads?.load?.();
        if (Array.isArray(saved) && saved.length > 0) {
          const fallback: Mode = (settings?.defaultMode as Mode) || "dream";
          const hydrated = saved.map((t: any) => ({ ...t, mode: t.mode ?? fallback }));
          threadsRef.current = hydrated;
          _setThreadList(hydrated);
          const last = hydrated[hydrated.length - 1];
          setActiveThreadId(last.id);
        }
      } finally {
        hasLoadedThreads.current = true;
      }
    })();
    const onClose = () => { void electron?.threads?.save?.(threadsRef.current); };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, [settings?.defaultMode, setThreadList]);

  // Healthz loop (adaptive)
  useEffect(() => {
    let alive = true;
    const timerRef = { current: null as number | null };
    const tick = async () => {
      if (timerRef.current) clearTimeout(timerRef.current);
      if (!alive) return;
      if (document.visibilityState === "visible") {
        try {
          const res = await (window as any).electron?.core?.healthz?.();
          const next: ConnectionStatus = res?.ok ? "ready" : "connecting";
          if (alive && next !== statusRef.current) {
            statusRef.current = next;
            setConnectionStatus(next);
          }
        } catch {
          if (alive && statusRef.current !== "connecting") {
            statusRef.current = "connecting";
            setConnectionStatus("connecting");
          }
        }
      }
      if (alive) {
        const delay = statusRef.current === "ready" ? 4000 : (document.visibilityState === 'visible' ? 1500 : 5000);
        timerRef.current = window.setTimeout(tick, delay);
      }
    };
    tick();
    document.addEventListener("visibilitychange", tick);
    return () => {
      alive = false;
      document.removeEventListener("visibilitychange", tick);
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);

  // First boot seed (optional)
  useEffect(() => {
    if (!hasLoadedThreads.current || seededOnceRef.current || connectionStatus !== "ready") return;
    if (threadsRef.current.length > 0) { seededOnceRef.current = true; return; }

    const newId = `thread-init-${Date.now()}`;
    const mode: Mode = "astrofuck";
    setThreadList([{
      id: newId,
      title: "first encounter",
      autoGenerated: false,
      messages: [{ sender: "Blur", text: `core is awake. ready in ${mode} mode.` }],
      sessionId: null,
      mode,
    }]);
    setActiveThreadId(newId);
    setCurrentMode(mode);
    seededOnceRef.current = true;
  }, [connectionStatus, setThreadList]);

  // Personalize greeting when present
  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    const list = threadsRef.current;
    if (!list.length || list[0].title !== "first encounter") return;
    const t0 = list[0];
    const idx = t0.messages.findIndex(m => m.sender === "Blur");
    if (idx === -1) return;
    const originalText = t0.messages[idx].text;
    const base = originalText.replace(/^hello\s\*\*.*?\*\*\.\s*/i, "");
    const name = (settings.userName || "").trim();
    const nextText = (name ? `hello **${name}**. ` : "") + base;
    if (originalText !== nextText) {
      setThreadList(prev => {
        const copy = [...prev];
        const first = { ...copy[0] };
        const msgs = [...first.messages];
        msgs[idx] = { ...msgs[idx], text: nextText };
        first.messages = msgs;
        copy[0] = first;
        return copy;
      });
    }
  }, [settings.userName, setThreadList]);

  // Theme + fonts
  useEffect(() => {
    document.body.className = settings.theme === "dark" ? "dark-theme" : "light-theme";
    document.documentElement.style.setProperty("--body-font", settings.bodyFont || "monospace");
    document.documentElement.style.setProperty("--interface-font", settings.interfaceFont || "monospace");
  }, [settings.theme, settings.bodyFont, settings.interfaceFont]);

  // Restore active id (optional)
  useEffect(() => {
    if (!hasLoadedThreads.current || restoredActiveOnceRef.current) return;
    (async () => {
      try {
        const savedActive = await (window as any).active?.load?.();
        if (savedActive && typeof savedActive === "string") setActiveThreadId((prev) => savedActive || prev);
      } finally {
        restoredActiveOnceRef.current = true;
      }
    })();
  }, []);

  // Persist active id
  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    void (window as any).active?.save?.(activeThreadId);
  }, [activeThreadId]);

  // Debounced save
  useEffect(() => {
    if (!hasLoadedThreads.current || !pendingSaveRef.current) return;
    if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    saveTimerRef.current = window.setTimeout(async () => {
      try { await (window as any).electron?.threads?.save?.(threadsRef.current); pendingSaveRef.current = false; } catch {}
    }, 250);
  }, [threadList]);

  const handleStopGeneration = useCallback(() => {
    if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
    streamConnectionRef.current?.close();
    streamConnectionRef.current = null;
    setIsLoading(false);
    pendingSaveRef.current = true;
  }, []);

  const handleNewConversation = useCallback(() => {
    handleStopGeneration();
    const newThread = prepareNewThread();
    setThreadList((prev) => [...prev, newThread]);
    setActiveThreadId(newThread.id);
    setCurrentMode(newThread.mode || "astrofuck");
    void (window as any).active?.save?.(newThread.id);
    pendingSaveRef.current = true;
  }, [handleStopGeneration, setThreadList]);

  const handleModeToggle = useCallback(() => {
    handleStopGeneration();
    if (!activeThreadId) return;
    const thread = threadsRef.current.find((t) => t.id === activeThreadId);
    const prevMode: Mode = thread?.mode ?? currentMode;
    const newMode: Mode = prevMode === "dream" ? "astrofuck" : "dream";
    setThreadList((prev) =>
      prev.map((t) => t.id === activeThreadId
        ? { ...t, mode: newMode, messages: [...t.messages, { sender: "System", text: `༄∞ᛝ𓆩⫷ ${newMode} ∆ møde ⫸𓆪ᛝ∞༄`, systemType: "announcement" }] }
        : t
      )
    );
    setCurrentMode(newMode);
    pendingSaveRef.current = true;
  }, [activeThreadId, currentMode, handleStopGeneration, setThreadList]);

  // 🔒 Single-source of truth: ensure a real, active thread exists.
  const ensureActiveThread = useCallback((): Thread => {
    // Try existing active
    if (activeThreadId) {
      const cur = threadsRef.current.find(t => t.id === activeThreadId);
      if (cur) return cur;
    }
    // Else create new
    const newThread = prepareNewThread();
    setThreadList(prev => [...prev, newThread]);
    setActiveThreadId(newThread.id);
    setCurrentMode(newThread.mode || "astrofuck");
    void (window as any).active?.save?.(newThread.id);
    pendingSaveRef.current = true;
    return newThread;
  }, [activeThreadId, setThreadList]);

  // ✅ FINAL: message sending that *never* drops on empty state.
  const handleNewCommand = useCallback(
    async (command: string, threadHint?: string) => {
      if (!command?.trim()) return;
      if (isLoading) return;

      setIsLoading(true);

      // Choose target thread: hint → active → create
      let target: Thread | undefined =
        (threadHint && threadsRef.current.find(t => t.id === threadHint)) ||
        (activeThreadId && threadsRef.current.find(t => t.id === activeThreadId));

      if (!target) target = ensureActiveThread(); // ← guarantees creation + activation

      // Append "You" + placeholder "Blur typing"
      const updated: Thread = {
        ...target,
        messages: [...target.messages, { sender: "You", text: command }, { sender: "Blur", text: "typing" }],
      };
      setThreadList(prev => prev.map(t => (t.id === updated.id ? updated : t)));
      pendingSaveRef.current = true;

      // Streaming setup
      accumulatedTextRef.current = "";
      streamStartedRef.current = false;
      const finalThreadId = updated.id;

      // Typing indicator spinner
      let dot = 1;
      const spin = () => {
        if (streamStartedRef.current || unmountedRef.current) {
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
          return;
        }
        setThreadList(prev => prev.map(t => {
          if (t.id !== finalThreadId) return t;
          const msgs = [...t.messages];
          const last = msgs[msgs.length - 1];
          if (!last || last.sender !== "Blur") return t;
          const dots = ".".repeat(dot);
          msgs[msgs.length - 1] = { ...last, text: `𓆩typing𓆪${dots.padEnd(3, " ")}` };
          return { ...t, messages: msgs };
        }));
        dot = (dot % 3) + 1;
      };
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      typingTickerRef.current = window.setInterval(spin, 350);

      const paint = (txt: string) => {
        setThreadList(prev => prev.map(t => {
          if (t.id !== finalThreadId) return t;
          const msgs = [...t.messages];
          const last = msgs[msgs.length - 1];
          if (!last || last.sender !== "Blur") return t;
          msgs[msgs.length - 1] = { ...last, text: txt };
          return { ...t, messages: msgs };
        }));
      };

      const sessionId = updated.sessionId ?? null;
      const modeForThisThread: Mode = updated.mode ?? currentMode;
      const params = new URLSearchParams({ prompt: command, mode: modeForThisThread, ...(sessionId && { session_id: sessionId }) });
      const url = `http://127.0.0.1:8000/generate_response_get?${params.toString()}`;
      const eventSource = new EventSource(url);
      streamConnectionRef.current = eventSource;

      const cleanupAndStop = () => {
        if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
        eventSource.close();
        if (streamConnectionRef.current === eventSource) { streamConnectionRef.current = null; }
        setIsLoading(false);
        pendingSaveRef.current = true;
      };

      eventSource.addEventListener("session_info", (event) => {
        try {
          const data = JSON.parse(event.data);
          const receivedSessionId = data.session_id;
          const threadToUpdate = threadsRef.current.find(t => t.id === finalThreadId);
          if (receivedSessionId && threadToUpdate?.sessionId !== receivedSessionId) {
            setThreadList(prev => prev.map(t => t.id === finalThreadId ? { ...t, sessionId: receivedSessionId } : t));
          }
        } catch (e) {
          console.error("[Session] Failed to parse session_info event:", e);
        }
      });

      eventSource.addEventListener("token", (event) => {
        if (unmountedRef.current) return;
        if (!streamStartedRef.current) {
          streamStartedRef.current = true;
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
        }
        const data = event.data || "";
        accumulatedTextRef.current = accumulatedTextRef.current === "" ? data : accumulatedTextRef.current + data;
        paint(accumulatedTextRef.current + "▍");
      });

      eventSource.addEventListener("final", (event) => {
        if (unmountedRef.current) return;
        try {
          const finalPayload = JSON.parse(event.data);
          paint(finalizeMarkdownStable(finalPayload.final));
        } catch {}
      });

      eventSource.addEventListener("done", cleanupAndStop);
      eventSource.onerror = (err) => {
        console.error("EventSource failed:", err);
        const errorMessage = `Ache Signal: Connection to core was interrupted.`;
        setThreadList(prev => prev.map(t => {
          if (t.id !== finalThreadId) return t;
          const newMessages = t.messages.slice(0, -1);
          return { ...t, messages: [...newMessages, { sender: "System", text: errorMessage }] };
        }));
        cleanupAndStop();
      };
    },
    [activeThreadId, currentMode, isLoading, setThreadList, ensureActiveThread]
  );

  const setActiveThread = useCallback((id: string | null) => {
    setActiveThreadId(id);
    if (!id) return;
    const t = threadsRef.current.find((x) => x.id === id);
    if (t?.mode && t.mode !== currentMode) setCurrentMode(t.mode);
  }, [currentMode]);

  const layoutProps = useMemo(
    () => ({
      activeItem: activeThreadId,
      setActiveItem: setActiveThread,
      sidebarCollapsed,
      setSidebarCollapsed,
      threadList,
      setThreadList,
      onNewCommand: handleNewCommand, // accepts (message: string, threadId?: string)
      onNewConversation: handleNewConversation,
      currentMode,
      onModeToggle: handleModeToggle,
      isLoading,
      connectionStatus,
      onStopGeneration: handleStopGeneration,
    }),
    [
      activeThreadId, sidebarCollapsed, threadList, setThreadList, handleNewCommand,
      handleNewConversation, currentMode, handleModeToggle, isLoading, connectionStatus,
      handleStopGeneration, setActiveThread,
    ]
  );

  return (
    <div className="w-full h-screen overflow-hidden">
      <TerminalLayout {...layoutProps} />
    </div>
  );
};

export function App() {
  return (
    <SettingsProvider>
      <AppErrorBoundary>
        <AppContent />
      </AppErrorBoundary>
    </SettingsProvider>
  );
}

export default App;
