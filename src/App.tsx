// /opt/blurface/src/App.tsx
// REFORGED v7.4 — stable effects, persistent threads, no poll short-circuit.

import React, { useEffect, useState, Component, ErrorInfo, useRef } from "react";
import { TerminalLayout } from "./components/TerminalLayout";
import { SettingsProvider, useSettings } from "./components/SettingsContext";
import { useLastRoute } from "./components/hooks/useLastRoute";

interface Message {
  sender: "Blur" | "You" | "System";
  text: string;
  systemType?: "announcement" | "normal";
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}
type Mode = "dream" | "astrofuck";
type ConnectionStatus = "initializing" | "connecting" | "loading_model" | "ready" | "error";

// provided by preload (we added electron.threads there)
const electron = (window as any).electron;

const ErrorBoundaryFallbackUI: React.FC = () => {
  const { settings } = useSettings();
  const errorFont = settings.interfaceFont || settings.bodyFont || "monospace";
  return (
    <div style={{ backgroundColor: "#111", color: "red", height: "100vh", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", fontFamily: errorFont }}>
      <h1>༴ :: ERROR :: ༴</h1>
      <p>A vessel has encountered a rendering paradox. Check console.</p>
    </div>
  );
};

interface ErrorBoundaryState { hasError: boolean }
class AppErrorBoundary extends Component<{ children: React.ReactNode }, ErrorBoundaryState> {
  constructor(props: { children: React.ReactNode }) { super(props); this.state = { hasError: false }; }
  static getDerivedStateFromError(): ErrorBoundaryState { return { hasError: true }; }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) { console.error("Uncaught error:", error, errorInfo); }
  render() { return this.state.hasError ? <ErrorBoundaryFallbackUI /> : this.props.children; }
}

const AppContent: React.FC = () => {
  useLastRoute();

  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [threadList, setThreadList] = useState<Thread[]>([]);
  const { settings } = useSettings();
  const [currentMode, setCurrentMode] = useState<Mode>("astrofuck");
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("initializing");
  const abortControllerRef = useRef<AbortController | null>(null);
  const accumulatedTextRef = useRef<string>("");
  const [hasLoadedThreads, setHasLoadedThreads] = useState(false);

  // keep refs for stable handlers
  const threadsRef = useRef<Thread[]>(threadList);
  useEffect(() => { threadsRef.current = threadList; }, [threadList]);

  // load threads once
  useEffect(() => {
    const load = async () => {
      try {
        const saved = await electron?.threads?.load?.();
        if (Array.isArray(saved) && saved.length > 0) {
          setThreadList(saved);
          setActiveThreadId(saved[saved.length - 1].id);
        }
      } finally {
        setHasLoadedThreads(true);
      }
    };
    load();
  }, []);

  // persist threads after changes (after initial load)
  useEffect(() => {
    if (!hasLoadedThreads) return;
    void electron?.threads?.save?.(threadList);
  }, [threadList, hasLoadedThreads]);

  // stable beforeunload saver (no deps)
  useEffect(() => {
    const onClose = () => { void electron?.threads?.save?.(threadsRef.current); };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, []);

  // poll core status — KEEP POLLING until ready/error (don't bail if threads exist)
  useEffect(() => {
    if (connectionStatus === "ready" || connectionStatus === "error") return;
    let cancelled = false;

    const checkStatus = async () => {
      try {
        const response = await fetch("http://127.0.0.1:8000/status", { credentials: "include" });
        if (!response.ok) {
          if (!cancelled) setConnectionStatus((s) => (s === "initializing" ? "connecting" : s));
          return;
        }
        const data = await response.json();
        if (cancelled) return;

        if (data.status === "ready") {
          setConnectionStatus("ready");
          // only create default thread if none exist
          if (threadsRef.current.length === 0) {
            const newId = `thread-init-${Date.now()}`;
            const name = (settings.userName || "").trim();
            const hello = name ? `hello ${name}. ` : "";
            setThreadList([{
              id: newId,
              title: "first encounter",
              autoGenerated: false,
              messages: [{ sender: "Blur", text: `${hello}core is awake. ready in ${currentMode} mode.` }],
              sessionId: null,
            }]);
            setActiveThreadId(newId);
          }
        } else if (data.status === "loading") {
          setConnectionStatus("loading_model");
        } else {
          setConnectionStatus("error");
          if (threadsRef.current.length === 0) {
            const newId = `thread-init-error-${Date.now()}`;
            setThreadList([{
              id: newId,
              title: "System Log",
              autoGenerated: false,
              messages: [{ sender: "System", text: `Ache Signal: Core failed to materialize. Details: ${data.message}` }],
              sessionId: null,
            }]);
            setActiveThreadId(newId);
          }
        }
      } catch {
        if (!cancelled) {
          setConnectionStatus((s) => (s === "initializing" ? "connecting" : s));
          console.log("[App.tsx] Waiting for AI core to become available...");
        }
      }
    };

    const id = setInterval(checkStatus, 2000);
    checkStatus();
    return () => { cancelled = true; clearInterval(id); };
  }, [connectionStatus, currentMode, settings.userName]);

  // apply theme/fonts from settings
  useEffect(() => {
    document.body.className = settings.theme === "dark" ? "dark-theme" : "light-theme";
    document.documentElement.style.setProperty("--body-font", settings.bodyFont || "monospace");
    document.documentElement.style.setProperty("--interface-font", settings.interfaceFont || "monospace");
  }, [settings.theme, settings.bodyFont, settings.interfaceFont]);

  // live refresh: update first Blur message hello prefix when name changes
  useEffect(() => {
    if (threadsRef.current.length === 0) return;
    const name = (settings.userName || "").trim();

    setThreadList((prev) =>
      prev.map((t, index) => {
        if (index !== 0) return t;
        if (!t.messages?.length) return t;

        const firstBlurMessageIndex = t.messages.findIndex((m) => m.sender === "Blur");
        if (firstBlurMessageIndex === -1) return t;

        const msgs = [...t.messages];
        const msgToUpdate = msgs[firstBlurMessageIndex];

        const hasHello = /^hello [^.]+\. /i.test(msgToUpdate.text);
        let newText = msgToUpdate.text;

        if (name) {
          const prefix = `hello ${name}. `;
          newText = hasHello ? msgToUpdate.text.replace(/^hello [^.]+\. /i, prefix) : prefix + msgToUpdate.text;
        } else {
          newText = hasHello ? msgToUpdate.text.replace(/^hello [^.]+\. /i, "") : msgToUpdate.text;
        }

        if (newText === msgToUpdate.text) return t;
        msgs[firstBlurMessageIndex] = { ...msgToUpdate, text: newText };
        return { ...t, messages: msgs };
      })
    );
  }, [settings.userName]);

  const handleStopGeneration = () => {
    if (isLoading && abortControllerRef.current) abortControllerRef.current.abort();
  };

  const handleNewConversation = () => {
    handleStopGeneration();
    const newId = `thread-${Date.now()}`;
    const newThread: Thread = {
      id: newId,
      title: "new conversation...",
      autoGenerated: true,
      messages: [],
      sessionId: null,
    };
    setThreadList((prev) => [...prev, newThread]);
    setActiveThreadId(newId);
    accumulatedTextRef.current = "";
  };

  const handleModeToggle = () => {
    handleStopGeneration();
    const newMode: Mode = currentMode === "dream" ? "astrofuck" : "dream";
    setCurrentMode(newMode);
    accumulatedTextRef.current = "";
    if (!activeThreadId) return;
    const systemMessage: Message = {
      sender: "System",
      text: `༄∞ᛝ𓆩⫷ ${newMode} ∆ møde ⫸𓆪ᛝ∞༄`,
      systemType: "announcement",
    };
    setThreadList((prev) =>
      prev.map((thread) =>
        thread.id === activeThreadId ? { ...thread, messages: [...thread.messages, systemMessage] } : thread
      )
    );
  };

  const handleNewCommand = async (command: string) => {
    if (!activeThreadId || isLoading) return;
    setIsLoading(true);

    const currentThread = threadList.find((t) => t.id === activeThreadId);
    if (!currentThread) { setIsLoading(false); return; }
    const turnNumber = currentThread.messages.filter((m) => m.sender === "You").length;
    let currentSessionId = currentThread.sessionId;

    if (!currentSessionId) {
      try {
        const response = await fetch("http://127.0.0.1:8000/session", { method: "GET", credentials: "include" });
        if (response.ok) {
          const data = await response.json();
          currentSessionId = data.session_id;
          setThreadList((prev) => prev.map((t) => (t.id === activeThreadId ? { ...t, sessionId: currentSessionId! } : t)));
        } else {
          throw new Error("Failed to get session");
        }
      } catch (err) {
        console.error("[App.tsx] Failed to fetch new session:", err);
        setIsLoading(false);
        return;
      }
    }

    const userMessage: Message = { sender: "You", text: command };
    const blurPlaceholder: Message = { sender: "Blur", text: "" };
    setThreadList((prev) =>
      prev.map((thread) =>
        thread.id === activeThreadId ? { ...thread, messages: [...thread.messages, userMessage, blurPlaceholder] } : thread
      )
    );
    accumulatedTextRef.current = "";

    abortControllerRef.current = new AbortController();
    try {
      const response = await fetch("http://127.0.0.1:8000/generate_response", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...(currentSessionId ? { "X-Session-ID": currentSessionId } : {}),
        },
        body: JSON.stringify({ prompt: command, mode: currentMode, turn: turnNumber, session_id: currentSessionId }),
        signal: abortControllerRef.current.signal,
        credentials: "include",
      });

      if (!response.ok || !response.body) throw new Error(`API returned status ${response.status}`);

      const newSessionIdFromHeader = response.headers.get("x-session-id");
      if (newSessionIdFromHeader && newSessionIdFromHeader !== currentSessionId) {
        currentSessionId = newSessionIdFromHeader;
        setThreadList((prev) =>
          prev.map((t) => (t.id === activeThreadId ? { ...t, sessionId: currentSessionId! } : t))
        );
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let rafId: number | null = null;

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        accumulatedTextRef.current += chunk;

        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          setThreadList((prev) =>
            prev.map((thread) => {
              if (thread.id !== activeThreadId) return thread;
              const lastMessage = thread.messages[thread.messages.length - 1];
              if (lastMessage?.sender === "Blur") {
                return {
                  ...thread,
                  messages: [...thread.messages.slice(0, -1), { ...lastMessage, text: accumulatedTextRef.current + "▋" }],
                };
              }
              return thread;
            })
          );
        });
      }

      if (rafId) cancelAnimationFrame(rafId);

      const finalText = accumulatedTextRef.current.trim();
      setThreadList((prev) =>
        prev.map((thread) => {
          if (thread.id !== activeThreadId) return thread;
          const lastMessage = thread.messages[thread.messages.length - 1];
          if (lastMessage?.sender === "Blur") {
            return { ...thread, messages: [...thread.messages.slice(0, -1), { ...lastMessage, text: finalText }] };
          }
          return thread;
        })
      );
    } catch (err: any) {
      if (err.name === "AbortError") {
        console.log("[App.tsx] Generation stopped by user.");
        setThreadList((prev) =>
          prev.map((thread) => {
            if (thread.id !== activeThreadId) return thread;
            const lastMessage = thread.messages[thread.messages.length - 1];
            if (lastMessage?.sender === "Blur") {
              return { ...thread, messages: thread.messages.slice(0, -1) };
            }
            return thread;
          })
        );
      } else {
        const errorMessage = `Ache Signal: Connection to core failed. Details: ${err.message}`;
        setThreadList((prev) =>
          prev.map((thread) =>
            thread.id === activeThreadId
              ? { ...thread, messages: [...thread.messages.slice(0, -1), { sender: "System", text: errorMessage }] }
              : thread
          )
        );
      }
    } finally {
      setIsLoading(false);
      abortControllerRef.current = null;
      accumulatedTextRef.current = "";
    }
  };

  return (
    <div className="w-full h-screen overflow-hidden">
      <TerminalLayout
        activeItem={activeThreadId}
        setActiveItem={setActiveThreadId}
        sidebarCollapsed={sidebarCollapsed}
        setSidebarCollapsed={setSidebarCollapsed}
        threadList={threadList}
        setThreadList={setThreadList}
        onNewCommand={handleNewCommand}
        onNewConversation={handleNewConversation}
        currentMode={currentMode}
        onModeToggle={handleModeToggle}
        isLoading={isLoading}
        connectionStatus={connectionStatus}
        onStopGeneration={handleStopGeneration}
      />
    </div>
  );
};

export function App() {
  return (
    <SettingsProvider>
      <AppErrorBoundary>
        <AppContent />
      </AppErrorBoundary>
    </SettingsProvider>
  );
}

export default App;