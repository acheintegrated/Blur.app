// src/lib/archiveStore.ts
// Lightweight localStorage archive for full threads

export type Sender = 'Blur' | 'You' | 'System';
export interface Message {
  sender: Sender;
  text: string;
  systemType?: 'announcement' | 'normal';
}
export interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}

const ARCHIVES_KEY = 'acheintegrated-archives';
const RESTORE_QUEUE_KEY = 'acheintegrated-archives-restore-queue';

function read<T>(key: string, fallback: T): T {
  try { return JSON.parse(localStorage.getItem(key) || '') as T } catch { return fallback }
}
function write<T>(key: string, val: T) {
  try { localStorage.setItem(key, JSON.stringify(val)) } catch {}
}

function previewOf(thread: Thread): string {
  // first non-system message or first line of any
  const first = thread.messages.find(m => m.sender !== 'System') ?? thread.messages[0];
  const text = first?.text ?? '';
  return text.split('\n').slice(0, 2).join(' ').slice(0, 200);
}

export const archiveStore = {
  all(): (Thread & { archivedAt: string })[] {
    return read<(Thread & { archivedAt: string })[]>(ARCHIVES_KEY, []);
  },
  saveAll(items: (Thread & { archivedAt: string })[]) { write(ARCHIVES_KEY, items) },

  get(id: string) {
    return this.all().find(t => t.id === id) || null;
  },

  archive(thread: Thread) {
    const items = this.all();
    const exists = items.some(t => t.id === thread.id);
    const archived: Thread & { archivedAt: string } = { ...thread, archivedAt: new Date().toISOString() };
    const next = exists ? items.map(t => (t.id === thread.id ? archived : t)) : [archived, ...items];
    this.saveAll(next);
  },

  remove(id: string) {
    this.saveAll(this.all().filter(t => t.id !== id));
  },

  clear() { this.saveAll([]) },

  // --- restore queue (hand-off back to main view) ---
  enqueueRestore(threads: Thread[]) {
    const q = read<Thread[]>(RESTORE_QUEUE_KEY, []);
    write(RESTORE_QUEUE_KEY, [...q, ...threads]);
  },
  dequeueAll(): Thread[] {
    const q = read<Thread[]>(RESTORE_QUEUE_KEY, []);
    write(RESTORE_QUEUE_KEY, []);
    return q;
  },

  // helpers for archive list UI
  toListItem(t: Thread & { archivedAt: string }) {
    return {
      id: t.id,
      title: t.title || 'Untitled',
      date: t.archivedAt,
      preview: previewOf(t),
    };
  },
};
