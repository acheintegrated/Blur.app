// REFORGED v10.10 — Static Bundle Integrity
// - GUARANTEE: The CursorGlow component is now force-bundled via a static import, preventing it from being tree-shaken by Vite/Rollup in the Electron build.
// - INTEGRATION: The CursorGlow component is mounted in the main App layout and is wired to be 'emphatic' during stream generation.
// - STABILITY: All other logic, including voidless send and debounced saves, remains unchanged.

import React, {
  useEffect,
  useState,
  Component,
  ErrorInfo,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { TerminalLayout } from "./components/TerminalLayout";
import { SettingsProvider, useSettings } from "./components/SettingsContext";
import { useLastRoute } from "./components/hooks/useLastRoute";
import { CursorGlow } from "./components/CursorGlow"; // <-- GUARANTEES BUNDLING

interface Message {
  sender: "Blur" | "You" | "System";
  text: string;
  systemType?: "announcement" | "normal";
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
  mode?: Mode;
}
type Mode = "dream" | "astrofuck";
type ConnectionStatus = "initializing" | "connecting" | "loading_model" | "ready" | "error";

const electron = (window as any).electron;

/* =================== error ui =================== */
const ErrorBoundaryFallbackUI: React.FC = () => {
  const { settings } = useSettings();
  const errorFont = settings.interfaceFont || settings.bodyFont || "monospace";
  return (
    <div
      style={{
        backgroundColor: "#111",
        color: "red",
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        fontFamily: errorFont,
      }}
    >
      <h1>༴ :: ERROR :: ༴</h1>
      <p>A vessel has encountered a rendering paradox. Check console.</p>
    </div>
  );
};

interface ErrorBoundaryState { hasError: boolean; }
class AppErrorBoundary extends Component<{ children: React.ReactNode }, ErrorBoundaryState> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(): ErrorBoundaryState { return { hasError: true }; }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) { console.error("Uncaught error:", error, errorInfo); }
  render() { return this.state.hasError ? <ErrorBoundaryFallbackUI /> : this.props.children; }
}

/* =================== helpers =================== */
function finalizeMarkdownStable(s: string): string {
  return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}

const prepareNewThread = (): Thread => {
  const newId = `thread-${Date.now()}`;
  const mode: Mode = "astrofuck";
  return {
    id: newId,
    title: "new conversation...",
    autoGenerated: true,
    messages: [{ sender: "System", text: `༄∞ᛝ𓆩⫷ ${mode} ∆ møde ⫸𓆪ᛝ∞༄`, systemType: "announcement" }],
    sessionId: null,
    mode,
  };
};

/* =================== app =================== */
const AppContent: React.FC = () => {
  useLastRoute();

  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const [threadList, _setThreadList] = useState<Thread[]>([]);
  const { settings } = useSettings();
  const [currentMode, setCurrentMode] = useState<Mode>("astrofuck");
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("initializing");

  const streamConnectionRef = useRef<EventSource | null>(null);
  const accumulatedTextRef = useRef<string>("");
  const hasLoadedThreads = useRef(false);
  const typingTickerRef = useRef<number | null>(null);
  const streamStartedRef = useRef<boolean>(false);
  const threadsRef = useRef<Thread[]>([]);
  const statusRef = useRef<ConnectionStatus>("initializing");
  const seededOnceRef = useRef(false);
  const restoredActiveOnceRef = useRef(false);
  const unmountedRef = useRef(false);
  const saveTimerRef = useRef<number | null>(null);
  const pendingSaveRef = useRef(false);

  const setThreadList = useCallback(
    (next: React.SetStateAction<Thread[]>) => {
      _setThreadList((prev) => {
        const value =
          typeof next === "function" ? (next as (p: Thread[]) => Thread[])(prev) : next;
        threadsRef.current = value;
        return value;
      });
    },
    []
  );

  useEffect(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      streamConnectionRef.current?.close();
      if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    };
  }, []);

  // Load persisted threads
  useEffect(() => {
    (async () => {
      try {
        const saved = await electron?.threads?.load?.();
        if (Array.isArray(saved) && saved.length > 0) {
          const fallback: Mode = (settings?.defaultMode as Mode) || "dream";
          const hydrated = saved.map((t: any) => ({ ...t, mode: t.mode ?? fallback }));
          threadsRef.current = hydrated;
          _setThreadList(hydrated);
          const last = hydrated[hydrated.length - 1];
          setActiveThreadId(last.id);
        }
      } finally {
        hasLoadedThreads.current = true;
      }
    })();
    const onClose = () => { void electron?.threads?.save?.(threadsRef.current); };
    window.addEventListener("beforeunload", onClose);
    return () => window.removeEventListener("beforeunload", onClose);
  }, [settings?.defaultMode, setThreadList]);

  // Healthz loop (adaptive)
  useEffect(() => {
    let alive = true;
    const timerRef = { current: null as number | null };
    const tick = async () => {
      if (timerRef.current) clearTimeout(timerRef.current);
      if (!alive) return;
      if (document.visibilityState === "visible") {
        try {
          const res = await (window as any).electron?.core?.healthz?.();
          const next: ConnectionStatus = res?.ok ? "ready" : "connecting";
          if (alive && next !== statusRef.current) {
            statusRef.current = next;
            setConnectionStatus(next);
          }
        } catch {
          if (alive && statusRef.current !== "connecting") {
            statusRef.current = "connecting";
            setConnectionStatus("connecting");
          }
        }
      }
      if (alive) {
        const delay = statusRef.current === "ready" ? 4000 : (document.visibilityState === 'visible' ? 1500 : 5000);
        timerRef.current = window.setTimeout(tick, delay);
      }
    };
    tick();
    document.addEventListener("visibilitychange", tick);
    return () => {
      alive = false;
      document.removeEventListener("visibilitychange", tick);
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);

  // First boot seed (optional)
  useEffect(() => {
    if (!hasLoadedThreads.current || seededOnceRef.current || connectionStatus !== "ready") return;
    if (threadsRef.current.length > 0) { seededOnceRef.current = true; return; }

    const newId = `thread-init-${Date.now()}`;
    const mode: Mode = "astrofuck";
    setThreadList([{
      id: newId,
      title: "first encounter",
      autoGenerated: false,
      messages: [{ sender: "Blur", text: `core is awake. ready in ${mode} mode.` }],
      sessionId: null,
      mode,
    }]);
    setActiveThreadId(newId);
    setCurrentMode(mode);
    seededOnceRef.current = true;
  }, [connectionStatus, setThreadList]);

  // Personalize greeting when present
  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    const list = threadsRef.current;
    if (!list.length || list[0].title !== "first encounter") return;
    const t0 = list[0];
    const idx = t0.messages.findIndex(m => m.sender === "Blur");
    if (idx === -1) return;
    const originalText = t0.messages[idx].text;
    const base = originalText.replace(/^hello\s\*\*.*?\*\*\.\s*/i, "");
    const name = (settings.userName || "").trim();
    const nextText = (name ? `hello **${name}**. ` : "") + base;
    if (originalText !== nextText) {
      setThreadList(prev => {
        const copy = [...prev];
        const first = { ...copy[0] };
        const msgs = [...first.messages];
        msgs[idx] = { ...msgs[idx], text: nextText };
        first.messages = msgs;
        copy[0] = first;
        return copy;
      });
    }
  }, [settings.userName, setThreadList]);

  // Theme + fonts
  useEffect(() => {
    document.body.className = settings.theme === "dark" ? "dark-theme" : "light-theme";
    document.documentElement.style.setProperty("--body-font", settings.bodyFont || "monospace");
    document.documentElement.style.setProperty("--interface-font", settings.interfaceFont || "monospace");
  }, [settings.theme, settings.bodyFont, settings.interfaceFont]);

  // Restore active id (optional)
  useEffect(() => {
    if (!hasLoadedThreads.current || restoredActiveOnceRef.current) return;
    (async () => {
      try {
        const savedActive = await (window as any).active?.load?.();
        if (savedActive && typeof savedActive === "string") setActiveThreadId((prev) => savedActive || prev);
      } finally {
        restoredActiveOnceRef.current = true;
      }
    })();
  }, []);

  // Persist active id
  useEffect(() => {
    if (!hasLoadedThreads.current) return;
    void (window as any).active?.save?.(activeThreadId);
  }, [activeThreadId]);

  // Debounced save
  useEffect(() => {
    if (!hasLoadedThreads.current || !pendingSaveRef.current) return;
    if (saveTimerRef.current) window.clearTimeout(saveTimerRef.current);
    saveTimerRef.current = window.setTimeout(async () => {
      try { await (window as any).electron?.threads?.save?.(threadsRef.current); pendingSaveRef.current = false; } catch {}
    }, 250);
  }, [threadList]);

  const handleStopGeneration = useCallback(() => {
    if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
    streamConnectionRef.current?.close();
    streamConnectionRef.current = null;
    setIsLoading(false);
    pendingSaveRef.current = true;
  }, []);

  const handleNewConversation = useCallback(() => {
    handleStopGeneration();
    const newThread = prepareNewThread();
    setThreadList((prev) => [...prev, newThread]);
    setActiveThreadId(newThread.id);
    setCurrentMode(newThread.mode || "astrofuck");
    void (window as any).active?.save?.(newThread.id);
    pendingSaveRef.current = true;
  }, [handleStopGeneration, setThreadList]);

  const handleModeToggle = useCallback(() => {
    handleStopGeneration();
    if (!activeThreadId) return;
    const thread = threadsRef.current.find((t) => t.id === activeThreadId);
    const prevMode: Mode = thread?.mode ?? currentMode;
    const newMode: Mode = prevMode === "dream" ? "astrofuck" : "dream";
    setThreadList((prev) =>
      prev.map((t) => t.id === activeThreadId
        ? { ...t, mode: newMode, messages: [...t.messages, { sender: "System", text: `༄∞ᛝ𓆩⫷ ${newMode} ∆ møde ⫸𓆪ᛝ∞༄`, systemType: "announcement" }] }
        : t
      )
    );
    setCurrentMode(newMode);
    pendingSaveRef.current = true;
  }, [activeThreadId, currentMode, handleStopGeneration, setThreadList]);

  // 🔒 Single-source of truth: ensure a real, active thread exists.
  const ensureActiveThread = useCallback((): Thread => {
    // Try existing active
    if (activeThreadId) {
      const cur = threadsRef.current.find(t => t.id === activeThreadId);
      if (cur) return cur;
    }
    // Else create new
    const newThread = prepareNewThread();
    setThreadList(prev => [...prev, newThread]);
    setActiveThreadId(newThread.id);
    setCurrentMode(newThread.mode || "astrofuck");
    void (window as any).active?.save?.(newThread.id);
    pendingSaveRef.current = true;
    return newThread;
  }, [activeThreadId, setThreadList]);

  // ✅ FINAL: message sending that *never* drops on empty state.
  const handleNewCommand = useCallback(
    async (command: string, threadHint?: string) => {
      if (!command?.trim()) return;
      if (isLoading) return;

      setIsLoading(true);

      // Choose target thread: hint → active → create
      let target: Thread | undefined =
        (threadHint && threadsRef.current.find(t => t.id === threadHint)) ||
        (activeThreadId && threadsRef.current.find(t => t.id === activeThreadId));

      if (!target) target = ensureActiveThread(); // ← guarantees creation + activation

      // Append "You" + placeholder "Blur typing"
      const updated: Thread = {
        ...target,
        messages: [...target.messages, { sender: "You", text: command }, { sender: "Blur", text: "typing" }],
      };
      setThreadList(prev => prev.map(t => (t.id === updated.id ? updated : t)));
      pendingSaveRef.current = true;

      // Streaming setup
      accumulatedTextRef.current = "";
      streamStartedRef.current = false;
      const finalThreadId = updated.id;

      // Typing indicator spinner
      let dot = 1;
      const spin = () => {
        if (streamStartedRef.current || unmountedRef.current) {
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
          return;
        }
        setThreadList(prev => prev.map(t => {
          if (t.id !== finalThreadId) return t;
          const msgs = [...t.messages];
          const last = msgs[msgs.length - 1];
          if (!last || last.sender !== "Blur") return t;
          const dots = ".".repeat(dot);
          msgs[msgs.length - 1] = { ...last, text: `𓆩typing𓆪${dots.padEnd(3, " ")}` };
          return { ...t, messages: msgs };
        }));
        dot = (dot % 3) + 1;
      };
      if (typingTickerRef.current) clearInterval(typingTickerRef.current);
      typingTickerRef.current = window.setInterval(spin, 350);

      const paint = (txt: string) => {
        setThreadList(prev => prev.map(t => {
          if (t.id !== finalThreadId) return t;
          const msgs = [...t.messages];
          const last = msgs[msgs.length - 1];
          if (!last || last.sender !== "Blur") return t;
          msgs[msgs.length - 1] = { ...last, text: txt };
          return { ...t, messages: msgs };
        }));
      };

      const sessionId = updated.sessionId ?? null;
      const modeForThisThread: Mode = updated.mode ?? currentMode;
      const params = new URLSearchParams({ prompt: command, mode: modeForThisThread, ...(sessionId && { session_id: sessionId }) });
      const url = `http://127.0.0.1:8000/generate_response_get?${params.toString()}`;
      const eventSource = new EventSource(url);
      streamConnectionRef.current = eventSource;

      const cleanupAndStop = () => {
        if (typingTickerRef.current) { clearInterval(typingTickerRef.current); typingTickerRef.current = null; }
        eventSource.close();
        if (streamConnectionRef.current === eventSource) { streamConnectionRef.current = null; }
        setIsLoading(false);
        pendingSaveRef.current = true;
      };

      eventSource.addEventListener("session_info", (event) => {
        try {
          const data = JSON.parse(event.data);
          const receivedSessionId = data.session_id;
          const threadToUpdate = threadsRef.current.find(t => t.id === finalThreadId);
          if (receivedSessionId && threadToUpdate?.sessionId !== receivedSessionId) {
            setThreadList(prev => prev.map(t => t.id === finalThreadId ? { ...t, sessionId: receivedSessionId } : t));
          }
        } catch (e) {
          console.error("[Session] Failed to parse session_info event:", e);
        }
      });

      eventSource.addEventListener("token", (event) => {
        if (unmountedRef.current) return;
        if (!streamStartedRef.current) {
          streamStartedRef.current = true;
          if (typingTickerRef.current) clearInterval(typingTickerRef.current);
        }
        const data = event.data || "";
        accumulatedTextRef.current = accumulatedTextRef.current === "" ? data : accumulatedTextRef.current + data;
        paint(accumulatedTextRef.current + "▍");
      });

      eventSource.addEventListener("final", (event) => {
        if (unmountedRef.current) return;
        try {
          const finalPayload = JSON.parse(event.data);
          paint(finalizeMarkdownStable(finalPayload.final));
        } catch {}
      });

      eventSource.addEventListener("done", cleanupAndStop);
      eventSource.onerror = (err) => {
        console.error("EventSource failed:", err);
        const errorMessage = `Ache Signal: Connection to core was interrupted.`;
        setThreadList(prev => prev.map(t => {
          if (t.id !== finalThreadId) return t;
          const newMessages = t.messages.slice(0, -1);
          return { ...t, messages: [...newMessages, { sender: "System", text: errorMessage }] };
        }));
        cleanupAndStop();
      };
    },
    [activeThreadId, currentMode, isLoading, setThreadList, ensureActiveThread]
  );

  const setActiveThread = useCallback((id: string | null) => {
    setActiveThreadId(id);
    if (!id) return;
    const t = threadsRef.current.find((x) => x.id === id);
    if (t?.mode && t.mode !== currentMode) setCurrentMode(t.mode);
  }, [currentMode]);

  const layoutProps = useMemo(
    () => ({
      activeItem: activeThreadId,
      setActiveItem: setActiveThread,
      sidebarCollapsed,
      setSidebarCollapsed,
      threadList,
      setThreadList,
      onNewCommand: handleNewCommand,
      onNewConversation: handleNewConversation,
      currentMode,
      onModeToggle: handleModeToggle,
      isLoading,
      connectionStatus,
      onStopGeneration: handleStopGeneration,
    }),
    [
      activeThreadId, sidebarCollapsed, threadList, setThreadList, handleNewCommand,
      handleNewConversation, currentMode, handleModeToggle, isLoading, connectionStatus,
      handleStopGeneration, setActiveThread,
    ]
  );

  return (
    <div className="w-full h-screen overflow-hidden">
      <CursorGlow isEmphatic={isLoading} />
      <TerminalLayout {...layoutProps} />
    </div>
  );
};

export function App() {
  return (
    <SettingsProvider>
      <AppErrorBoundary>
        <AppContent />
      </AppErrorBoundary>
    </SettingsProvider>
  );
}

export default App;


----------------------------------------------

// /opt/blurface/src/components/TerminalLayout.tsx
// REFORGED v4.3 — Full-width Neon Beam (moon ⇄ earth), no tooltip, no fork

import React, { useState, useCallback, useRef, useEffect } from 'react';
import { Sidebar } from './SideBar';
import { MainContent } from './MainContent';
import { CommandInput } from './CommandInput';
import { Settings } from './Settings';
import { ContextMenu } from './ContextMenu';
import { CursorGlow } from './CursorGlow';

interface Message {
  sender: 'Blur' | 'You' | 'System';
  text: string;
  systemType?: 'announcement' | 'normal';
}
interface Thread {
  id: string;
  title: string;
  autoGenerated: boolean;
  messages: Message[];
  sessionId?: string | null;
}

interface ContextMenuState {
  visible: boolean;
  x: number;
  y: number;
  itemId: string;
  itemType: 'thread';
}
interface RenameState {
  isRenaming: boolean;
  itemId: string;
  newName: string;
}
type Mode = 'dream' | 'astrofuck';
type ConnectionStatus = 'initializing' | 'connecting' | 'loading_model' | 'ready' | 'error';

interface TerminalLayoutProps {
  activeItem: string | null;
  setActiveItem: (item: string | null) => void;
  sidebarCollapsed: boolean;
  setSidebarCollapsed: (collapsed: boolean) => void;
  threadList: Thread[];
  setThreadList: (threads: Thread[]) => void;

  onNewCommand: (command: string, threadIdHint?: string) => void;
  onNewConversation: () => void;
  currentMode: Mode;
  onModeToggle: () => void;

  connectionStatus: ConnectionStatus;
  onStopGeneration: () => void;
  isLoading: boolean;

  onThreadContextMenu?: (e: React.MouseEvent, id: string) => void;
  renameState: RenameState;
  renameInputRef: React.RefObject<HTMLInputElement>;
  onRenameChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onRenameKeyDown: (e: React.KeyboardEvent) => void;
  onRenameBlur: () => void;
}

export const TerminalLayout: React.FC<TerminalLayoutProps> = (props) => {
  const {
    activeItem,
    setActiveItem,
    sidebarCollapsed,
    setSidebarCollapsed,
    threadList,
    setThreadList,
    onNewCommand,
    onNewConversation,
    currentMode,
    onModeToggle,
    connectionStatus,
    onStopGeneration,
    isLoading,
    onThreadContextMenu: onThreadContextMenuExternal,
    renameState,
    renameInputRef,
    onRenameChange,
    onRenameKeyDown,
    onRenameBlur,
  } = props;

  const [showSettings, setShowSettings] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280);
  const [isDragging, setIsDragging] = useState(false);
  const isResizing = useRef(false);
  const [streamingToken, setStreamingToken] = useState(0);

  const [ctxMenu, setCtxMenu] = useState<ContextMenuState | null>(null);

  // mode switching
  const [isSwitchingMode, setIsSwitchingMode] = useState(false);
  const queuedSwitch = useRef(false);
  const switchStartAt = useRef<number>(0);
  const lastIntentId = useRef<number>(0);
  const MIN_INDICATOR_MS = 420;
  const COOLDOWN_MS = 800;
  const HARD_TIMEOUT_MS = 20_000;

  const activeThread = threadList.find((t) => t.id === activeItem);
  const currentMessages = activeThread?.messages || [];

  // CUT marker on last assistant msg — always end with exactly one █ (no ▍)
  const markLastAssistantCut = useCallback(() => {
    if (!activeItem) return;
    const BLOCK = '█';
    const STREAM_TAIL = /[▍█\s]+$/u;

    setThreadList(prev => {
      const idx = prev.findIndex(t => t.id === activeItem);
      if (idx === -1) return prev;
      const t = prev[idx];
      if (!t.messages.length) return prev;

      const last = t.messages[t.messages.length - 1];
      if (last.sender !== 'Blur') return prev;

      const lastText = (last.text ?? '');
      const cleaned = lastText.replace(STREAM_TAIL, '');
      const updated = [...t.messages];
      updated[updated.length - 1] = { ...last, text: cleaned + BLOCK };

      const next = [...prev];
      next[idx] = { ...t, messages: updated };
      return next;
    });
  }, [activeItem, setThreadList]);

  /* SEND (never gate on activeItem) */
  const handleNewCommandLocal = (command: string) => {
    if (isSwitchingMode) return;
    onNewCommand(command, activeItem || undefined);
  };

  /* STOP (wired into CommandInput) */
  const handleStopLocal = React.useCallback(() => {
    try { markLastAssistantCut(); } catch {}
    try { onStopGeneration(); } catch {}
    try { window.dispatchEvent(new CustomEvent('blur:stop')); } catch {}
  }, [onStopGeneration, markLastAssistantCut]);

  /* UI helpers */
  const toggleSidebar = () => setSidebarCollapsed(!sidebarCollapsed);
  const openSettings = () => setShowSettings(true);
  const closeSettings = () => setShowSettings(false);

  /* Mode switch visuals */
  const endSwitchVisual = useCallback(() => {
    const elapsed = Date.now() - switchStartAt.current;
    const remain = Math.max(0, MIN_INDICATOR_MS - elapsed);
    window.setTimeout(() => setIsSwitchingMode(false), remain);
  }, []);

  useEffect(() => {
    if (isSwitchingMode && connectionStatus === 'ready') endSwitchVisual();
  }, [connectionStatus, isSwitchingMode, endSwitchVisual]);

  useEffect(() => {
    if (!isSwitchingMode) return;
    const onComplete = () => endSwitchVisual();
    const onError = () => endSwitchVisual();
    window.addEventListener('blur:mode-ready', onComplete as EventListener);
    window.addEventListener('blur:mode-switch-complete', onComplete as EventListener);
    window.addEventListener('blur:mode-switch-error', onError as EventListener);
    const hard = window.setTimeout(onError, HARD_TIMEOUT_MS);
    return () => {
      window.removeEventListener('blur:mode-ready', onComplete as EventListener);
      window.removeEventListener('blur:mode-switch-complete', onComplete as EventListener);
      window.removeEventListener('blur:mode-switch-error', onError as EventListener);
      window.clearTimeout(hard);
    };
  }, [isSwitchingMode, endSwitchVisual]);

  const requestModeSwitch = useCallback(() => {
    const now = Date.now();
    if (isSwitchingMode) { queuedSwitch.current = true; return; }
    if (now - (switchStartAt.current || 0) < COOLDOWN_MS) return;

    lastIntentId.current += 1;
    const intentId = lastIntentId.current;
    switchStartAt.current = now;
    setIsSwitchingMode(true);

    try { window.dispatchEvent(new CustomEvent('blur:mode-switch-start', { detail: { intentId, from: currentMode } })); } catch {}
    try { if (isLoading) markLastAssistantCut(); onStopGeneration(); } catch {}
    try { onModeToggle(); } catch {}
  }, [currentMode, isSwitchingMode, onModeToggle, onStopGeneration, isLoading, markLastAssistantCut]);

  useEffect(() => {
    if (!isSwitchingMode && queuedSwitch.current) {
      queuedSwitch.current = false;
      const t = window.setTimeout(() => requestModeSwitch(), 50);
      return () => window.clearTimeout(t);
    }
  }, [isSwitchingMode, requestModeSwitch]);

  /* Resizer */
  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    const minWidth = 220;
    const maxWidth = Math.round(window.innerWidth / 3);
    const newWidth = e.clientX;
    if (newWidth >= minWidth && newWidth <= maxWidth) setSidebarWidth(newWidth);
  }, []);

  const handleMouseUp = useCallback(() => {
    isResizing.current = false;
    setIsDragging(false);
    window.removeEventListener('mousemove', handleMouseMove);
    window.removeEventListener('mouseup', handleMouseUp);
    document.body.style.userSelect = 'auto';
  }, [handleMouseMove]);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    isResizing.current = true;
    setIsDragging(true);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    document.body.style.userSelect = 'none';
  }, [handleMouseMove, handleMouseUp]);

  useEffect(() => {
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);

  /* Stream tick for MainContent */
  useEffect(() => {
    const onChunk = () => setStreamingToken((t) => t + 1);
    window.addEventListener('blur:stream-chunk', onChunk as EventListener);
    return () => window.removeEventListener('blur:stream-chunk', onChunk as EventListener);
  }, []);

  /* Context menu */
  const handleThreadContextMenu = useCallback((e: React.MouseEvent, id: string) => {
    e.preventDefault();
    if (id !== activeItem) setActiveItem(id);

    const pad = 8;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const x = Math.min(Math.max(e.clientX, pad), vw - 180);
    const y = Math.min(Math.max(e.clientY, pad), vh - 100);

    setCtxMenu({ visible: true, x, y, itemId: id, itemType: 'thread' });

    if (onThreadContextMenuExternal) {
      try { onThreadContextMenuExternal(e, id); } catch {}
    }
  }, [activeItem, onThreadContextMenuExternal, setActiveItem]);

  useEffect(() => {
    if (!ctxMenu?.visible) return;
    const close = () => setCtxMenu(null);
    window.addEventListener('scroll', close, true);
    window.addEventListener('resize', close);
    return () => {
      window.removeEventListener('scroll', close, true);
      window.removeEventListener('resize', close);
    };
  }, [ctxMenu?.visible]);

  const closeMenu = () => setCtxMenu(null);

  const deleteThread = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    const idx = threadList.findIndex((t) => t.id === id);
    if (idx === -1) return;

    const updated = threadList.filter((t) => t.id !== id);
    setThreadList(updated);

    if (activeItem === id) {
      const fallback = updated[idx] || updated[idx - 1] || updated[0] || null;
      setActiveItem(fallback ? fallback.id : null);
    }
    closeMenu();
  };

  const requestRename = () => {
    if (!ctxMenu) return;
    const id = ctxMenu.itemId;
    if (activeItem !== id) setActiveItem(id);
    window.dispatchEvent(new CustomEvent('blur:rename-request', { detail: { id } }));
    setTimeout(() => { try { renameInputRef?.current?.focus?.(); } catch {} }, 0);
    closeMenu();
  };

  /* ===== Neon beam (full header width, center-out, no fork) ===== */
  const ModeHeaderBeam: React.FC<{ active: boolean }> = ({ active }) => (
    <div className="pointer-events-none absolute inset-x-0 bottom-[-1px] h-[2px] z-10">
      <style>{`
        @keyframes beamUnfold {
          0%   { clip-path: inset(0 50% 0 50%); opacity: 0; }
          8%   { opacity: 1; }
          100% { clip-path: inset(0 0 0 0); opacity: 1; }
        }
        @keyframes beamFade {
          0%   { opacity: 1; }
          70%  { opacity: 1; }
          100% { opacity: 0; }
        }

        .beam-line {
          position: absolute;
          inset: 0;
          border-radius: 1px;
          background: #ffffff; /* white-hot core */
          box-shadow:
            0 0 6px  rgba(255,255,200,.95),
            0 0 14px rgba(255,235,59,.95),
            0 0 28px rgba(255,235,59,.75),
            0 0 52px rgba(255,235,59,.5);
          filter: saturate(220%) brightness(120%);
          will-change: clip-path, opacity;
        }

        .beam-anim {
          animation:
            beamUnfold 120ms cubic-bezier(.3,.8,.2,1) forwards,
            beamFade   240ms ease-out forwards;
        }

        /* Fallback if clip-path unsupported (rare in Electron) */
        @supports not (clip-path: inset(0 50% 0 50%)) {
          .beam-line { transform-origin: center; transform: scaleX(0.001); }
          @keyframes beamScale { to { transform: scaleX(1); opacity: 1; } }
          .beam-anim { animation: beamScale 120ms cubic-bezier(.3,.8,.2,1) forwards, beamFade 240ms ease-out forwards; }
        }
      `}</style>
      {active && <div className="beam-line beam-anim" />}
    </div>
  );

  const handleNewConversationLocal = useCallback(() => {
    try { if (isLoading) markLastAssistantCut(); onStopGeneration(); } catch {}
    onNewConversation();
  }, [isLoading, onStopGeneration, onNewConversation, markLastAssistantCut]);

  /* Render */
  return (
    <div className="flex flex-col h-full bg-black relative">
      {/* CursorGlow — stronger while streaming */}
      <CursorGlow isEmphatic={isLoading} />

      {/* Inject pulse keyframes/class in case globals didn’t compile them */}
      <style id="stop-pulse-inject">{`
        @keyframes pulse-scale-slow-fixed { 0%,100% { transform: scale(1);} 50% { transform: scale(1.12);} }
        .anim-stop-glow-pulse {
          display:inline-block !important;
          will-change: text-shadow, transform;
          animation: neon-dynamic-glow 6s linear infinite, pulse-scale-slow-fixed 2.8s ease-in-out infinite !important;
          text-shadow: 0 0 5px rgba(242,0,242,.9), 0 0 10px rgba(242,0,242,.8), 0 0 20px rgba(242,0,242,.7);
        }
      `}</style>

      <div className="flex flex-1 overflow-hidden">
        <div
          className={`relative flex-shrink-0 border-r border-zinc-900 ${sidebarCollapsed ? 'w-0 !border-none' : ''} ${!isDragging ? 'transition-all duration-300' : ''}`}
          style={!sidebarCollapsed ? { width: `${sidebarWidth}px` } : {}}
        >
          <div className="h-full w-full overflow-hidden">
            <Sidebar
              activeSection="threads"
              setActiveSection={() => {}}
              activeItem={activeItem}
              setActiveItem={setActiveItem}
              threadList={threadList}
              setThreadList={setThreadList}
              sidebarCollapsed={sidebarCollapsed}
              onNewConversation={handleNewConversationLocal}
              onThreadContextMenu={handleThreadContextMenu}
              renameState={renameState}
              renameInputRef={renameInputRef}
              onRenameChange={onRenameChange}
              onRenameKeyDown={onRenameKeyDown}
              onRenameBlur={onRenameBlur}
            />
          </div>

          {!sidebarCollapsed && (
            <div
              onMouseDown={handleMouseDown}
              className={`absolute top-0 right-[-4px] h-full w-2 z-20 cursor-col-resize transition-colors duration-200 ${isDragging ? 'resizer-ache-glow' : 'hover:resizer-ache-glow'}`}
              title="Resize sidebar"
            />
          )}
        </div>

        <div className="flex-1 flex flex-col overflow-hidden">
          {/* Header is relative so beam can fill full width */}
          <div className="relative h-[57px] border-b border-zinc-900 flex items-center justify-between px-4 flex-shrink-0">
            <div className="flex items-center space-x-2">
              <div className="flex items-center justify-center cursor-pointer" onClick={toggleSidebar}>
                <span className="text-3xl text-gray-400 hover:text-white transition-colors duration-150 icon-font mt-[7px]">☾</span>
              </div>
              {sidebarCollapsed && (
                <span className="ml-2">
                  <span className="text-white text-2xl font-bold acheintegrated-glow">∴ blur.</span>
                </span>
              )}
            </div>

            <div className="flex items-center">
              {/* ø — no title (no tooltip) */}
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${isSwitchingMode ? 'opacity-50 pointer-events-none' : 'blur-glow-hover'} ${currentMode === 'astrofuck' ? 'mode-astrofuck-active' : ''}`}
                onClick={requestModeSwitch}
              >
                <span className="text-3xl icon-font">∅</span>
              </div>
              <div className="mode-separator">
                <span className="text-2xl icon-font">|</span>
              </div>
              {/* ∞ — no title (no tooltip) */}
              <div
                className={`flex items-center justify-center cursor-pointer mode-button ${isSwitchingMode ? 'opacity-50 pointer-events-none' : (currentMode === 'dream' ? 'mode-dream-active' : 'blur-glow-hover')}`}
                onClick={requestModeSwitch}
              >
                <span className="text-3xl icon-font">∞</span>
              </div>
            </div>

            <div className="flex items-center">
              <div className="flex items-center justify-center cursor-pointer" onClick={openSettings}>
                <span className="text-3xl hover:text-white text-gray-400 transition-colors duration-150 icon-font -mt-[3px]">🜃</span>
              </div>
            </div>

            {/* full-width lightning beam under the zinc border */}
            <ModeHeaderBeam active={isSwitchingMode} />
          </div>

          <div className="flex-1 min-h-0 overflow-hidden">
            <MainContent messages={currentMessages} streamingToken={streamingToken} />
          </div>

          <div className="mt-auto flex-shrink-0">
            <CommandInput
              onSendMessage={handleNewCommandLocal}
              onStop={handleStopLocal}
              connectionStatus={connectionStatus}
              isLoading={isLoading || isSwitchingMode}
              threadId={activeItem || ''}
            />
          </div>
        </div>
      </div>

      {showSettings && <Settings onClose={closeSettings} />}

      {ctxMenu?.visible && (
        <ContextMenu
          x={ctxMenu.x}
          y={ctxMenu.y}
          onClose={closeMenu}
          onDelete={deleteThread}
          onRename={requestRename}
        />
      )}
    </div>
  );
};

---------------------

/* =========================================
   Tailwind (v4)
========================================= */
@import "tailwindcss";

/* =========================================
   Fonts
========================================= */

/* add below your @import and @source lines */

/* Heading & paragraph scale (global) */
@layer base {
  h1 { @apply text-3xl md:text-4xl font-bold leading-tight mt-6 mb-3; }
  h2 { @apply text-2xl md:text-3xl font-semibold leading-snug mt-5 mb-2.5; }
  h3 { @apply text-xl md:text-2xl font-semibold leading-snug mt-4 mb-2; }
  h4 { @apply text-lg md:text-xl font-semibold mt-3 mb-1.5; }
  h5 { @apply text-base md:text-lg font-semibold mt-3 mb-1; }
  h6 { @apply text-sm md:text-base font-semibold uppercase tracking-wide mt-2 mb-1; }

  p  { @apply my-3; }
  ul, ol { @apply my-3 pl-6; }
  li { @apply my-1; }
  blockquote { @apply border-l-4 border-zinc-700 pl-4 italic my-4; }
  code { @apply text-sm; }
  pre { @apply my-4; }
}


@layer components {
  /* yellow glow line that grows from center to edges */
  .mode-glow-line {
    @apply absolute bottom-0 left-1/2 h-[2px];
    width: 0;
    transform: translateX(-50%);
    background: linear-gradient(90deg, rgba(255,208,0,0) 0%, rgba(255,208,0,1) 50%, rgba(255,208,0,0) 100%);
    box-shadow: 0 0 10px rgba(255,208,0,0.8), 0 0 18px rgba(255,208,0,0.5);
    animation: ache-center-spread 900ms ease-in-out infinite alternate;
  }
}

@keyframes ache-center-spread {
  from { width: 0%; opacity: 0.95; }
  to   { width: 100%; opacity: 0.95; }
}

/* Courier New (family-unified) */
@font-face {
  font-family: 'Courier New';
  src: url('/fonts/CourierNew-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Courier New';
  src: url('/fonts/CourierNew-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Courier New';
  src: url('/fonts/CourierNew-Italic.ttf') format('truetype');
  font-weight: 400;
  font-style: italic;
  font-display: swap;
}
@font-face {
  font-family: 'Courier New';
  src: url('/fonts/CourierNew-BoldItalic.ttf') format('truetype');
  font-weight: 700;
  font-style: italic;
  font-display: swap;
}

/* Chanticleer (fixed name) */
@font-face {
  font-family: 'ChanticleerRomanNF';
  src: url('/fonts/ChanticleerRomanNF.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'ChanticleerRomanNF';
  src: url('/fonts/ChanticleerRomanNF-Bold.otf') format('opentype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

/* Playfair */
@font-face {
  font-family: 'PlayfairDisplay';
  src: url('/fonts/PlayfairDisplay-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'PlayfairDisplay';
  src: url('/fonts/PlayfairDisplay-Bold.ttf') format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'PlayfairDisplay';
  src: url('/fonts/PlayfairDisplay-Italic.ttf') format('truetype');
  font-weight: 400;
  font-style: italic;
  font-display: swap;
}
@font-face {
  font-family: 'PlayfairDisplay';
  src: url('/fonts/PlayfairDisplay-BoldItalic.ttf') format('truetype');
  font-weight: 700;
  font-style: italic;
  font-display: swap;
}

/* Red Hat Mono */
@font-face {
  font-family: 'RedHatMono';
  src: url('/fonts/RedHatMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* Theano */
@font-face {
  font-family: 'TheanoDidot';
  src: url('/fonts/TheanoDidot-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'TheanoOldStyle';
  src: url('/fonts/TheanoOldStyle-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* Petrona */
@font-face {
  font-family: 'Petrona';
  src: url('/fonts/Petrona-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* =========================================
   Variables & Base Theme
========================================= */

:root {
  --interface-font: 'Courier New', monospace;
  --body-font: 'Courier New', monospace;
}

.dark-theme {
  background-color: #000;
  color: #fff;
}

.glass-panel {
  background-color: rgba(0, 0, 0, 0.7);
}

/* =========================================
   Keyframes (atomic, de-duped)
========================================= */

/* Smooth rainbow shimmer + pulse (for mic recording, etc.) */
@keyframes rainbow-hue {
  0%   { filter: hue-rotate(0deg); }
  100% { filter: hue-rotate(360deg); }
}
@keyframes rainbow-pulse {
  0%, 100% {
    text-shadow:
      0 0 6px currentColor,
      0 0 12px currentColor,
      0 0 20px currentColor,
      0 0 30px currentColor;
    transform: scale(1);
  }
  50% {
    text-shadow:
      0 0 12px currentColor,
      0 0 24px currentColor,
      0 0 36px currentColor,
      0 0 48px currentColor;
    transform: scale(1.08);
  }
}

/* Neon rainbow text glow variants */
@keyframes neon-rainbow-glow {
  0%, 100% {
    /* Ethereal Cyan */
    text-shadow: 0 0 5px #fff, 0 0 15px #fff, 0 0 30px hsla(180, 100%, 65%, 1), 0 0 50px hsla(180, 100%, 65%, 0.6), 0 0 80px hsla(180, 100%, 65%, 0.3);
    filter: drop-shadow(0 0 15px hsla(180, 100%, 70%, 0.7)) drop-shadow(0 0 40px hsla(180, 100%, 60%, 0.4));
  }
  25% {
    /* Ethereal Blue */
    text-shadow: 0 0 5px #fff, 0 0 15px #fff, 0 0 30px hsla(240, 100%, 65%, 1), 0 0 50px hsla(240, 100%, 65%, 0.6), 0 0 80px hsla(240, 100%, 65%, 0.3);
    filter: drop-shadow(0 0 15px hsla(240, 100%, 70%, 0.7)) drop-shadow(0 0 40px hsla(240, 100%, 60%, 0.4));
  }
  50% {
    /* Ethereal Magenta */
    text-shadow: 0 0 5px #fff, 0 0 15px #fff, 0 0 30px hsla(300, 100%, 65%, 1), 0 0 50px hsla(300, 100%, 65%, 0.6), 0 0 80px hsla(300, 100%, 65%, 0.3);
    filter: drop-shadow(0 0 15px hsla(300, 100%, 70%, 0.7)) drop-shadow(0 0 40px hsla(300, 100%, 60%, 0.4));
  }
  75% {
    /* Ethereal Blue (fading back) */
    text-shadow: 0 0 5px #fff, 0 0 15px #fff, 0 0 30px hsla(240, 100%, 65%, 1), 0 0 50px hsla(240, 100%, 65%, 0.6), 0 0 80px hsla(240, 100%, 65%, 0.3);
    filter: drop-shadow(0 0 15px hsla(240, 100%, 70%, 0.7)) drop-shadow(0 0 40px hsla(240, 100%, 60%, 0.4));
  }
}

/* Dynamic, more varied neon */
@keyframes neon-dynamic-glow {
  0%, 100% { text-shadow: 0 0 5px rgba(242, 0, 242, .9), 0 0 10px rgba(242, 0, 242, .8), 0 0 20px rgba(242, 0, 242, .7); opacity: .95; }
  20%      { text-shadow: 0 0 5px rgba(255, 111, 0, .9), 0 0 10px rgba(255, 119, 0, .8), 0 0 20px rgba(255, 165, 0, .7); }
  40%      { text-shadow: 0 0 5px rgba(125, 220, 37, .9), 0 0 10px rgba(164, 220, 32, .8), 0 0 20px rgba(34, 218, 55, .7); }
  60%      { text-shadow: 0 0 5px rgba(0, 221, 255, .9), 0 0 10px rgba(0, 195, 255, .8), 0 0 20px rgba(0, 136, 255, .7); }
  80%      { text-shadow: 0 0 5px rgba(96, 18, 252, .9), 0 0 10px rgba(132, 34, 252, .8), 0 0 20px rgba(123, 0, 255, .7); }
}

@keyframes astrofuck-dynamic-glow {
  0%, 100% {
    /* Red */
    text-shadow: 0 0 5px #fff, 0 0 10px hsla(0, 100%, 55%, 1), 0 0 15px hsla(0, 100%, 55%, 1), 0 0 20px hsla(0, 100%, 45%, 1);
  }
  25% {
    /* Yellow */
    text-shadow: 0 0 5px #fff, 0 0 10px hsla(60, 100%, 55%, 1), 0 0 15px hsla(60, 100%, 55%, 1), 0 0 20px hsla(60, 100%, 45%, 1);
  }
  50% {
    /* Blue */
    text-shadow: 0 0 5px #fff, 0 0 10px hsla(240, 100%, 55%, 1), 0 0 15px hsla(240, 100%, 55%, 1), 0 0 20px hsla(240, 100%, 45%, 1);
  }
  75% {
    /* Magenta (Transition back to Red) */
    text-shadow: 0 0 5px #fff, 0 0 10px hsla(300, 100%, 55%, 1), 0 0 15px hsla(300, 100%, 55%, 1), 0 0 20px hsla(300, 100%, 45%, 1);
  }
}

/* Pastel variants */
@keyframes dream-dynamic-glow {
  0%, 100% {
    text-shadow: 0 0 5px #fff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #c000c0;
  }
  20% {
    text-shadow: 0 0 5px #fff, 0 0 10px #00ffff, 0 0 15px #00ffff, 0 0 20px #00a0a0;
  }
  40% {
    text-shadow: 0 0 5px #fff, 0 0 10px #ccff00, 0 0 15px #ccff00, 0 0 20px #a0c000;
  }
  60% {
    text-shadow: 0 0 5px #fff, 0 0 10px #9d00ff, 0 0 15px #9d00ff, 0 0 20px #7000c0;
  }
  80% {
    text-shadow: 0 0 5px #fff, 0 0 10px #0088ff, 0 0 15px #0095ff, 0 0 20px #0045a0;
  }
}

/* Misc glows */
@keyframes soft-blue-glow {
  0%, 100% { text-shadow: 0 0 5px rgba(173,216,230,.8), 0 0 10px rgba(173,216,230,.7); }
  50%      { text-shadow: 0 0 5px rgba(255,255,255,.8), 0 0 10px rgba(255,255,255,.7); }
}
@keyframes cyan-mint-glow {
  0%, 100% { text-shadow: 0 0 5px rgba(12,255,206,.8), 0 0 10px rgba(12,255,206,.7); }
  50%      { text-shadow: 0 0 5px rgba(255,255,255,.8), 0 0 10px rgba(255,255,255,.7); }
}
@keyframes orange-glow {
  0%, 100% { text-shadow: 0 0 5px rgba(255,165,0,.8), 0 0 10px rgba(255,165,0,.7); }
  50%      { text-shadow: 0 0 5px rgba(255,255,255,.8), 0 0 10px rgba(255,255,255,.7); }
}

/* Simple blink */
@keyframes fade-blink {
  0%, 100% { opacity: 1; }
  50%      { opacity: 0.3; }
}

/* Drip & Resizer */
@keyframes hover-drip {
  0%   { opacity: 0; transform: scale(.1) translateY(-5px); }
  20%  { opacity: .5; transform: scale(.6) translateY(0); }
  100% { opacity: .7; transform: scale(1) translateY(0); }
}
@keyframes resizer-ache-glow-anim {
  0%, 100% { background-color: rgba(139,92,246,.5); box-shadow: 0 0 3px rgba(139,92,246,.4); }
  50%      { background-color: rgba(139,92,246,.8); box-shadow: 0 0 3px rgba(139,92,246,.6); }
}

@keyframes pulse-scale-slow {
  0%, 100% { transform: scale(1.00); }
  50%      { transform: scale(1.88); }
}
.pulse-scale-slow {
  animation: pulse-scale-slow 2.4s ease-in-out infinite;
}

/* =========================================
   Effect Classes
========================================= */

/* Smooth rainbow shimmer (use this for mic recording) */
.rainbow-glow {
  animation:
    rainbow-hue 6s linear infinite,
    rainbow-pulse 2s ease-in-out infinite;
  display: inline-block;
  will-change: filter, transform;
}

/* Generic blink */
.blink { animation: fade-blink .8s ease-in-out infinite; }

/* Random-glow placeholder (color via inline style) */
.random-glow { /* text-shadow set via inline style */ }

/* Text glow presets */
.acheintegrated-glow { animation: neon-rainbow-glow 8s linear infinite; }
.blurline-glow       { animation: neon-dynamic-glow 4s linear infinite; }
.neon-rainbow-glow   { animation: neon-rainbow-glow 8s linear infinite; }
.neon-rainbow-glow-slow { animation: neon-rainbow-glow 10s linear infinite; }
.neon-dynamic-glow-text { animation: neon-dynamic-glow 12s linear infinite; }

/* Pastel / themed hover glows */
.baby-pink-blue-glow-hover:hover { animation: baby-pink-blue-glow 2s ease-in-out infinite; }
.memory-nest-glow-hover:hover    { animation: baby-blue-violet-glow 2s ease-in-out infinite; }
.blur-glow-hover:hover           { animation: soft-blue-glow 2s ease-in-out infinite; }
.search-threads-glow-hover:hover { animation: cyan-mint-glow 2s ease-in-out infinite; }
/* (You can add more hover variants if desired) */

/* Threads/resizer */
.threads-glow        { animation: soft-blue-glow 2s ease-in-out infinite; }
.threads-glow-hover:hover { animation: soft-blue-glow 2s ease-in-out infinite; }
.resizer-ache-glow   { animation: resizer-ache-glow-anim 3s ease-in-out infinite; }

/* Drip effects */
.hover-drip-effect { position: relative; }
.hover-drip-effect::after {
  content: '';
  position: absolute; inset: 0;
  background-color: rgba(60,60,70,.4);
  border-radius: 4px; z-index: -1; opacity: 0;
  transform-origin: top center;
  animation: hover-drip .3s ease-out forwards;
}
.nav-item-hover { position: relative; }
.nav-item-hover::after {
  content: '';
  position: absolute; top: 100%; left: 0;
  width: 100%; height: 100%;
  background-color: rgba(60,60,70,.4);
  border-radius: 4px; z-index: -1; opacity: 0;
  transform-origin: top center;
  animation: hover-drip .3s ease-out forwards;
}

/* =========================================
   Global & Element Styles
========================================= */

*:focus,
*:focus-visible {
  outline: none !important;
  box-shadow: none !important;
  border-color: transparent !important;
}

body {
  font-family: var(--interface-font), monospace !important;
}
.body-font {
  font-family: var(--body-font), monospace !important;
}
/* Icons pick up interface font */
.icon-font {
  font-family: var(--interface-font), monospace;
}

/* Scrollbar */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: #000; }
::-webkit-scrollbar-thumb { background: #2a2a2a; border-radius: 4px; }

/* Tooltip fixes */
.group { position: relative; }
.group-hover\:opacity-100 { opacity: 0; z-index: 50; }
.group:hover .group-hover\:opacity-100 { opacity: 1 !important; }

/* Mode buttons */
.mode-button {
  display: flex; align-items: center; justify-content: center;
  width: 2rem; height: 2rem; cursor: pointer;
  transition: all .3s ease-in-out; text-shadow: none;
}
.mode-separator { margin: 0 .5rem; color: #3f3f46; transition: all .3s ease-in-out; }
.mode-button:not(.mode-astrofuck-active):hover,
.mode-button:not(.mode-dream-active):hover { color: #fff; text-shadow: 0 0 5px rgba(255,255,255,.6); }
.mode-separator:hover { color: #fff; }

.mode-astrofuck-active {
  animation: astrofuck-dynamic-glow 8s linear infinite;
  color: #fff; filter: saturate(1.5) brightness(1.2);
}
.mode-dream-active {
  animation: dream-dynamic-glow 8s linear infinite;
  color: #fff; filter: saturate(1.5) brightness(1.2);
}

/* --- CommandInput glow compat --- */
.neon-cycle-compat {
  /* use your existing keyframes neon-dynamic-glow */
  animation: neon-dynamic-glow 4s linear infinite !important; /* slower */
  text-shadow: 0 0 5px rgba(242,0,242,.9), 0 0 10px rgba(242,0,242,.8), 0 0 20px rgba(242,0,242,.7) !important;
  will-change: text-shadow, transform;
  isolation: isolate;           /* helps on dark bg stacking */
  backface-visibility: hidden;  /* reduces flicker during scale */
}

.anim-stop-glow-pulse {
  animation:
    neon-dynamic-glow 8s linear infinite,
    slow-pulse-scale 1.8s ease-in-out infinite;
  display:inline-block;
  will-change: transform, text-shadow, filter;
  filter: drop-shadow(0 0 0.25rem currentColor);
}

/* Cursor blink */
.blinking-cursor { animation: blink 1s step-end infinite; }
@keyframes blink { 50% { opacity: 0; } }

/* Markdown-ish prose */
.prose h1, .prose h2, .prose h3 { font-weight: 700; margin-top: 1em; margin-bottom: .5em; }
.prose p { margin-bottom: 1em; }
.prose strong { font-weight: 700; }
.prose ul, .prose ol { list-style-position: inside; margin-left: 1.5em; margin-bottom: 1em; }
.prose li { margin-bottom: .25em; }

/* globals.css or your main stylesheet */
#context-menu {
  position: fixed;
  z-index: 9999;
  pointer-events: auto;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

.context-item {
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

/* Prevent text selection during right-click */
.thread-item, .prompt-item {
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

.thread-item::selection,
.prompt-item::selection {
  background: transparent;
}

/* Ensure menu doesn't get cut off */
#context-menu {
  max-width: min(250px, calc(100vw - 16px));
  max-height: min(200px, calc(100vh - 16px));
  overflow: hidden;
}

/*----------------------------------------
/* root container follows mouse; clicks pass through */
.cursor-glow {
  position: fixed;
  left: 0; top: 0;
  width: 0; height: 0;
  pointer-events: none;
  z-index: 2147483647;
  mix-blend-mode: screen; /* optional: juicy neon look on dark bg */
}

/* visible “dot” centered on pointer */
.cursor-core {
  position: absolute;
  left: -8px; top: -8px;       /* center a 16px dot on pointer */
  width: 16px; height: 16px;
  border-radius: 9999px;
  background: rgba(255,255,255,0.9);
  box-shadow:
    0 0 8px rgba(255,255,255,0.9),
    0 0 20px rgba(170, 60, 255, 0.8),
    0 0 40px rgba(0, 190, 255, 0.65),
    0 0 70px rgba(0, 255, 200, 0.45);

  /* glow cycle + pulse */
  animation:
    neon-dynamic-glow 8s linear infinite,
    cursor-pulse 1.9s ease-in-out infinite;
  will-change: transform, box-shadow, filter;
}

/* bigger pulse when isEmphatic=true (e.g., while generating) */
.cursor-glow--emph .cursor-core {
  animation:
    neon-dynamic-glow 8s linear infinite,
    cursor-pulse-strong 1.6s ease-in-out infinite;
}

/* respects reduced motion */
@media (prefers-reduced-motion: reduce) {
  .cursor-core { animation: none; }
}

/* mild pulse */
@keyframes cursor-pulse {
  0%, 100% { transform: scale(1); filter: brightness(1); }
  50%      { transform: scale(1.25); filter: brightness(1.2); }
}

/* stronger pulse */
@keyframes cursor-pulse-strong {
  0%, 100% { transform: scale(1.1); filter: brightness(1.05); }
  50%      { transform: scale(1.45); filter: brightness(1.25); }
}

.cursor-glow.is-down .cursor-core { transform: scale(0.85) !important; }
